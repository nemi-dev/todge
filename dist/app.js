/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/Game.ts":
/*!*********************!*\
  !*** ./app/Game.ts ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Game; });\n/* harmony import */ var _You__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./You */ \"./app/You.ts\");\n/* harmony import */ var _Thing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Thing */ \"./app/Thing.ts\");\n/* harmony import */ var _Moving__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Moving */ \"./app/Moving.ts\");\n/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Timer */ \"./app/Timer.ts\");\n\n\n\n\nconst maxSpawnDelay = 160;\nconst minSpawnCount = 1;\nconst varSpawnCount = 10;\nconst maxTunaDelay = 900;\nconst enemy = {\n    speed: 1.2,\n    size: 5,\n    life: 600,\n    color: \"#FF0000\",\n    diverge: Math.PI / 2,\n    damage: 2\n};\nconst bigEnemy = {\n    speed: 0.8,\n    size: 10,\n    life: 1200,\n    color: \"#FF00FF\",\n    diverge: Math.PI / 3,\n    damage: 4\n};\nconst fastEnemy = {\n    speed: 2.4,\n    size: 5,\n    life: 400,\n    color: \"#FF8000\",\n    diverge: Math.PI / 6,\n    damage: 1\n};\nconst followDistance = 10;\nconst minDistOfTunaArraw = 50;\nconst maxDistOfTunaArrow = 120;\nconst minDistOfShowingArrow = 80;\nconst D = maxDistOfTunaArrow - minDistOfTunaArraw;\nconst p = minDistOfShowingArrow - D;\nconst k = -D * D;\nconst tunaArrowAngle = Math.PI / 15;\nfunction getTunaArrowDistance(realDistance) {\n    return k / (realDistance - p) + maxDistOfTunaArrow;\n}\nwindow.d = getTunaArrowDistance;\nclass GuideText {\n    constructor(text, x, y, size, weight) {\n        this.x = x;\n        this.y = y;\n        this.text = text;\n        this.font = `${weight} ${size}px \"Exo 2\", \"Noto Sans KR\"`;\n    }\n    render(context, a) {\n        let { x, y, text } = this;\n        context.fillStyle = `hsla(200, 100%, 70%, ${a})`;\n        context.font = this.font;\n        context.fillText(text, x, y);\n    }\n}\nconst guideMaxLife = 30;\nconst guideTextDistance = 60;\nconst yourMaxSpeed = 0.9;\nconst viewboxAcc = 0.025;\nconst viewboxCloseDistance = 20;\nclass GuideTextGroup {\n    constructor() {\n        this.texts = [\n            new GuideText(\"땃\\u2014쥐!\", 0, -guideTextDistance, 20, \"bold\"),\n            new GuideText(\"Todge\", 0, -guideTextDistance + 15, 12, \"bold\"),\n            new GuideText(\"참치캔을 먹어서\", -guideTextDistance, -4, 7, \"normal\"),\n            new GuideText(\"생명을 유지하세요\", -guideTextDistance, 4, 7, \"normal\"),\n            new GuideText(\"사방에서 몰려오는\", guideTextDistance, -4, 7, \"normal\"),\n            new GuideText(\"철충들을 피하세요\", guideTextDistance, 4, 7, \"normal\"),\n            new GuideText(\"길게 눌러 이동\", 0, guideTextDistance, 10, \"bold\")\n        ];\n        this.init(0);\n    }\n    init(t) {\n        this.guideLife = guideMaxLife;\n    }\n    get valid() { return this.guideLife > 0; }\n    update(t) {\n        this.guideLife--;\n    }\n    render(context) {\n        context.textAlign = \"center\";\n        context.textBaseline = \"middle\";\n        const a = this.guideLife / guideMaxLife;\n        for (const text of this.texts)\n            text.render(context, a);\n    }\n}\nclass Game {\n    constructor(viewbox) {\n        /** 가이드 텍스트 */\n        this.guide = new GuideTextGroup();\n        /** 원래 뷰박스에는 속도 속성이 없으므로 움직일 수 있는 어떤 객체가 뷰박스를 대신하는 것으로 한다. 뷰박스를 정의한 의도에 따라서라면 속도 속성을 추가시키는게 좋겠지만, 뷰 계열 클래스는 rAF와는 상관없다. 그게 아니면 뷰박스를 쓰지 말던가... */\n        this.viewboxReplica = new _Moving__WEBPACK_IMPORTED_MODULE_2__[\"Moving\"](yourMaxSpeed, viewboxAcc, viewboxCloseDistance);\n        // moveViewboxToTarget : Function\n        // viewboxFriction : Function\n        this.torusWidth = 220;\n        this.torusHeight = 280;\n        this.onPointStart = this._onstartInitial;\n        this.onPointMove = this.noop;\n        let you = new _You__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n        this.you = you;\n        this.viewbox = viewbox;\n        this.mat = viewbox.matrix;\n        this.timer = new _Timer__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n        this.init(0);\n    }\n    /** 게임을 처음 상태 (대기 상태)로 돌린다. */\n    init(t) {\n        this.status = \"free\";\n        this.you.init();\n        this.enemies = [];\n        this.tunas = [];\n        this.guide.init(t);\n        this.viewboxReplica.init();\n        this.viewbox.setPosition(0, 0);\n        this.enemySpawnCounter = 0;\n        this.totalEnemiesNumber = 0;\n        this.tunaSpawnCounter = 0;\n        this.timer.startTime = t;\n        this.timer.currentTime = t;\n        this.onPointStart = this._onstartInitial;\n        this.update = this.updateInit;\n        this.onPointMove = this.noop;\n    }\n    /** 게임을 시작 상태로 만든다. */\n    start(t) {\n        this.status = \"start\";\n        this.timer.start(t);\n        this.onPointStart = this._onstartPlaying;\n        this.update = this.updatePlay;\n        this.onPointMove = this._onPointMoveUpdate;\n    }\n    /** 게임을 종료 상태로 만든다. */\n    gameover(t) {\n        this.status = \"dead\";\n        this.timer.end(t);\n        this.you.moving.removeDestination();\n        this.onPointStart = this._onstartDead;\n        this.update = this.updateGameover;\n        this.onPointMove = this.noop;\n    }\n    /**\n     * 랜덤으로 오브젝트를 생성한다.\n     */\n    createThingRandom() {\n        const chance = Math.pow(this.enemySpawnCounter / (maxSpawnDelay + 1), 2);\n        const sight = this.you.sight;\n        const { x: yourX, y: yourY } = this.you.moving;\n        if (Math.random() < chance) {\n            const count = Math.floor(Math.random() * varSpawnCount) + minSpawnCount;\n            for (let i = 0; i < count; i++) {\n                let profile;\n                const roll = Math.random();\n                if (roll < 0.05)\n                    profile = fastEnemy;\n                else if (roll < 0.075)\n                    profile = bigEnemy;\n                else\n                    profile = enemy;\n                let angle = Math.random() * Math.PI * 2;\n                let distance = sight * 1.5;\n                let x = yourX + Math.cos(angle) * distance;\n                let y = yourY + Math.sin(angle) * distance;\n                const thing = new _Thing__WEBPACK_IMPORTED_MODULE_1__[\"Enemy\"](\"enemy\", x, y, angle, profile);\n                this.enemies.push(thing);\n                this.enemySpawnCounter = 0;\n                this.totalEnemiesNumber++;\n            }\n        }\n        this.enemySpawnCounter++;\n        const tunaChance = this.tunaSpawnCounter / maxTunaDelay - 0.3;\n        if (Math.random() < tunaChance / 20) {\n            let angle = Math.random() * Math.PI * 2;\n            let distance = sight * (0.5 + Math.random());\n            let x = yourX + Math.cos(angle) * distance;\n            let y = yourY + Math.sin(angle) * distance;\n            this.tunas.push(new _Thing__WEBPACK_IMPORTED_MODULE_1__[\"Tuna\"](x, y));\n            this.tunaSpawnCounter = 0;\n        }\n        else {\n            this.tunaSpawnCounter++;\n        }\n    }\n    /** 아직 게임이 시작되지 않았을 때 마우스 누름/터치 시작 핸들러 */\n    _onstartInitial(m) {\n        this.you.moving.setDestination(...this.mat.itransformPoint(m.startX, m.startY));\n        this.start(m.startTime);\n    }\n    /** 게임 플레이 중 누름 핸들러 */\n    _onstartPlaying(m) {\n        this.you.moving.setDestination(...this.mat.itransformPoint(m.startX, m.startY));\n    }\n    /** 게임오버 되었을 때 누름 핸들러 */\n    _onstartDead(m) {\n        this.init(m.startTime);\n    }\n    /** 마우스를 놓을 때 */\n    onPointEnd(m) {\n        this.you.moving.removeDestination();\n    }\n    /** 아무 것도 하지 않는다. */\n    noop(...a) { }\n    /** 게임 플레이 중 입력좌표 업데이트를 받을 때 실행한다. */\n    _onPointMoveUpdate(c) {\n        let [x, y] = this.mat.itransformPoint(c.x, c.y);\n        this.you.moving.setDestination(x, y);\n    }\n    /** 뷰박스를 플레이어에게로 옮긴다. */\n    moveViewboxToYou() {\n        const replica = this.viewboxReplica;\n        let viewDistX = this.you.x - this.viewboxReplica.x;\n        let viewDistY = this.you.y - this.viewboxReplica.y;\n        let distance = Math.hypot(viewDistX, viewDistY);\n        if (distance > followDistance) {\n            replica.setDestination(this.you.x, this.you.y);\n        }\n        else {\n            replica.removeDestination();\n        }\n        replica.update();\n        this.viewbox.move(replica.velX, replica.velY);\n    }\n    /** 객체들을 업데이트한다. 여기에는 삭제도 포함된다. */\n    _update_things(t) {\n        const limit = this.you.sight * 3;\n        for (let i = this.enemies.length - 1; i >= 0; i--) {\n            const enemy = this.enemies[i];\n            if (!enemy.valid || (Math.abs(enemy.x - this.you.x) > limit || Math.abs(enemy.y - this.you.y) > limit)) {\n                this.enemies.splice(i, 1);\n            }\n        }\n        for (let i = this.tunas.length - 1; i >= 0; i--) {\n            if (!this.tunas[i].valid) {\n                this.tunas.splice(i, 1);\n            }\n        }\n        for (const enemy of this.enemies)\n            enemy.update(this);\n        for (const tuna of this.tunas)\n            tuna.update(this);\n    }\n    updateInit(t) {\n    }\n    updatePlay(t) {\n        this.timer.update(t);\n        this.you.update(this);\n        this.you.drain();\n        this.moveViewboxToYou();\n        if (!this.you.valid) {\n            this.gameover(t);\n        }\n        if (this.guide.valid)\n            this.guide.update(t);\n        this._update_things(t);\n        this.createThingRandom();\n    }\n    updateGameover(t) {\n        this.you.update(this);\n        this._update_things(t);\n    }\n    hitTest() {\n        const you = this.you;\n        for (const enemy of this.enemies) {\n            if (Object(_Thing__WEBPACK_IMPORTED_MODULE_1__[\"hit\"])(you, enemy)) {\n                you.health -= enemy.profile.damage;\n                enemy.dispose();\n            }\n        }\n        for (const tuna of this.tunas) {\n            if (Object(_Thing__WEBPACK_IMPORTED_MODULE_1__[\"hit\"])(you, tuna)) {\n                you.health = you.maxHealth;\n                you.life = you.maxLife;\n                tuna.dispose();\n            }\n        }\n    }\n    renderCount(context, x, y) {\n        context.font = '16px \"Exo 2\"';\n        context.fillText(this.totalEnemiesNumber.toString(), x, y);\n    }\n    renderTunaDirection(context, x, y) {\n        context.fillStyle = \"hsla(45, 100%, 75%, 0.25)\";\n        const { x: vx, y: vy } = this.viewboxReplica;\n        for (const tuna of this.tunas) {\n            const dx = tuna.x - vx;\n            const dy = tuna.y - vy;\n            const distance = Math.hypot(dx, dy);\n            if (distance > minDistOfShowingArrow) {\n                const nearDist = getTunaArrowDistance(distance);\n                const farDist = nearDist + 10;\n                const angle = Math.atan2(dy, dx);\n                context.beginPath();\n                context.moveTo(x + Math.cos(angle) * farDist, y + Math.sin(angle) * farDist);\n                context.lineTo(x + Math.cos(angle - tunaArrowAngle) * nearDist, y + Math.sin(angle - tunaArrowAngle) * nearDist);\n                context.lineTo(x + Math.cos(angle + tunaArrowAngle) * nearDist, y + Math.sin(angle + tunaArrowAngle) * nearDist);\n                context.fill();\n            }\n        }\n    }\n    render(context) {\n        if (this.guide.valid)\n            this.guide.render(context);\n        this.you.renderSprite(context);\n        for (const enemies of this.enemies)\n            enemies.renderHitbox(context);\n        for (const tuna of this.tunas)\n            tuna.renderHitbox(context);\n        this.you.renderHitbox(context);\n        this.you.renderLight(context);\n    }\n    renderUI(context) {\n        const { velX, velY } = this.viewboxReplica;\n        const x = -velX * 4;\n        const y = -velY * 4;\n        this.you.renderYourUI(context, x, y, followDistance * 4);\n        this.renderTunaDirection(context, x, y);\n        context.textBaseline = \"middle\";\n        context.fillStyle = \"hsla(200, 100%, 70%, 0.25)\";\n        context.textAlign = 'center';\n        this.renderCount(context, x, y - this.viewbox.height / 4);\n        this.timer.render(context, x, y + this.viewbox.height / 4);\n    }\n}\n\n\n//# sourceURL=webpack:///./app/Game.ts?");

/***/ }),

/***/ "./app/Input.ts":
/*!**********************!*\
  !*** ./app/Input.ts ***!
  \**********************/
/*! exports provided: PointState, Detector, MouseInput, TouchInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PointState\", function() { return PointState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Detector\", function() { return Detector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MouseInput\", function() { return MouseInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TouchInput\", function() { return TouchInput; });\n/*\n    @update 2020-06-25\n    하나의 이니셰이티브에서 리스너는 게임(Game 객체)하나로 국한된다. 따라서 리스너는 오직 하나다. 이니셰이티브 종속적인 컴포넌트로 까지 떨어뜨릴 수도 있지만.... 그렇겐 하지말자 ㅎㅎ\n*/\n/**\n * 전적으로 rAF-Sync를 위해 표현되는 위치 객체로, 현재 rAF에서의 위치와 직전 rAF에서의 위치를 나타낸다.\n * 직전 \"이벤트\"의 위치가 아닌 직전 \"rAF\"인 것에 주의할 것!\n * */\nclass PointState {\n    /** @readonly 현재 x좌표 */\n    get x() { return this.currentX; }\n    /** @readonly 현재 y좌표 */\n    get y() { return this.currentY; }\n    /** @readonly 직전 rAF에서 X좌표 */\n    get beforeX() { return this._beforeX; }\n    /** @readonly 직전 rAF에서 y좌표 */\n    get beforeY() { return this._beforeY; }\n    /** @readonly 직전 rAF에서 현재 rAF까지의 x 변위 */\n    get moveX() {\n        return (this.beforeX != null) && (this.currentX != null) ? (this.currentX - this._beforeX) : 0;\n    }\n    /** @readonly 직전 rAF에서 현재 rAF까지의 y 변위 */\n    get moveY() {\n        return (this.beforeY != null) && (this.currentY != null) ? (this.currentY - this._beforeY) : 0;\n    }\n    /** 쌩 입력값을 이것으로 한다. */\n    input(x, y) {\n        this.inputX = x;\n        this.inputY = y;\n    }\n    /** current 값을 강제로 주어진 값으로 한다.\n     * 이렇게 하면 마우스 눌림/터치 시작 때 pulse가 실행되면 입력된 값들이 before 값으로 떨어지게 된다. */\n    shim(x, y) {\n        this.currentX = x;\n        this.currentY = y;\n    }\n    /** 현재 상태를 이전 상태로, 쌩 입력 좌표를 현재 상태로 전이시킨다. */\n    pulse() {\n        this._beforeX = this.currentX;\n        this._beforeY = this.currentY;\n        this.currentX = this.inputX;\n        this.currentY = this.inputY;\n    }\n}\n/** 입력 인터페이스를 눈치껏 알아채는 객체 */\nclass Detector {\n    constructor() {\n        this.detected = false;\n    }\n    disconnect() {\n        document.removeEventListener('mousedown', this.mouse);\n        document.removeEventListener('touchstart', this.touch);\n        this.detected = true;\n    }\n    open() {\n        if (this.detected)\n            return;\n        this.mouse = ev => {\n            this.whenItsMouse(ev);\n            this.disconnect();\n        };\n        this.touch = ev => {\n            this.whenItsTouch(ev);\n            this.disconnect();\n        };\n        document.addEventListener('mousedown', this.mouse);\n        document.addEventListener('touchstart', this.touch);\n    }\n}\nclass PointMessageQueue {\n    constructor() {\n        this.messageQueue = [];\n    }\n    push(m) {\n        this.messageQueue.unshift(m);\n    }\n    dispatchAll() {\n        let m;\n        while ((m = this.messageQueue.pop()) != null) {\n            switch (m.type) {\n                case \"mousedown\":\n                case \"touchstart\":\n                    this.listener.onPointStart(m);\n                    break;\n                case \"mouseup\":\n                case \"touchend\":\n                    this.listener.onPointEnd(m);\n                    break;\n            }\n        }\n    }\n}\n/**\n * 마우스 입력을 받아들여서 리스너에게 전달하는 클래스\n * 이 클래스는 requestAnimationFrame()을 사용한 업데이트 패턴에 특화된 구조를 가지고 있다.\n * 중요하고 양이 비교적 적은 이벤트(마우스 누름, 마우스 놓음)는 매 이벤트 루프마다 놓치지 않고 캡쳐해 두고, 압도적으로 많이 발생하고 중요하지 않은 이벤트(마우스 움직임)는 변화에 따라 \"현재 상태\"와 \"직전 상태\"만을 저장해 두고 rAF에서 그 상태를 참조하도록 하고 있다.\n * 이 입력 객체는 특히 \"마우스를 누를 때\"에만 실제 좌표를 전달한다.\n * 그리고 사실 이벤트 큐 처리와 rAF는 (거의) 같은 사이클에 일어난다. 스로틀링 같은 걸 일으키는 똥컴이 아니라면 말이지...\n */\nclass MouseInput extends PointMessageQueue {\n    constructor() {\n        super(...arguments);\n        /** (rAF?) 지금 누르고 있는 버튼 */\n        this.buttons = 0;\n        /**\n         * 마우스 누름 발생 시, 언젠가 발생할 마우스 떼기에 대응하여 임시로 메시지를 만들어 저장해 둘 배열\n         * messagePool[n]은 n번 마우스 버튼 누름에 대응하는 임시 마우스 떼기 메시지이다.\n         * n번 마우스 버튼 떼기가 발생하면 messagePool[n]에 있는 메시지를 꺼내서 end 값을 입력하고 큐에 넣는다.\n         * */\n        this.messageCache = [];\n        /** rAF 발생 당시 마우스 누름 중일 때 사용할 수 있는 좌표 컴포넌트 */\n        this.point = new PointState();\n        /**\n         * 마우스 누름 이벤트 발생 시 실행된다.\n         * 화살표 함수로 만들어놓지 않으면 TypeScript 버그 때문인지, 놓친 게 있는지는 모르겠지만 this 바인딩이 제대로 되지 않는다는 문제가 있다.\n         * */\n        this.onstart = (ev) => {\n            ev.preventDefault();\n            this.buttons = ev.buttons;\n            let { offsetX: startX, offsetY: startY, button: id, timeStamp: startTime } = ev;\n            /*\n            이전 위치와 현재 위치를 마우스 누름 위치로 한다. 이 두 줄은 다음과 같은 상황이 있을 때를 대비하고 있다.\n    \n            1. 클릭/터치 시작과 rAF 사이에 움직임이 있을 수 있다.\n            2. 클릭/터치 시작과 끝 사이에 움직임이 없다.\n            */\n            this.point.shim(startX, startY);\n            this.point.input(startX, startY);\n            /* 메시지 큐에 클릭/터치 시작 메시지를 추가한다. 이것은 그야말로 rAF와 이벤트 간의 불협화음이 있을거라 생각하고 만들었기 때문에 수정이 필요해 보인다. */\n            this.push({ type: \"mousedown\", id, startX, startY, startTime });\n            /** 나중에 클릭/터치가 끝이 났을 때 짝(해당하는 마우스 버튼/ 터치 ID)이 맞는 메시지를 디스패치하기 위해 클릭/터치 끝 메시지를 미리 만들어 놓는다. */\n            this.messageCache[id] = { type: \"mouseup\", id, startX, startY, startTime };\n            return false;\n        };\n        /** 마우스 누름 여부와 상관없이 마우스를 움직일 때 실행된다. */\n        this.onmove = (ev) => {\n            this.point.input(ev.offsetX, ev.offsetY);\n        };\n        this.onend = (ev) => {\n            this.buttons = ev.buttons;\n            /* mouseup 이벤트는 버블 가능하므로 리스너가 도큐먼트에 연결되어 있어도 eventTarget이 source이면 offset값은 여전히 source에 상대적인 위치가 된다. */\n            let x = ev.offsetX;\n            let y = ev.offsetY;\n            // 마우스 누름 당시 저장했던 마우스 놓기 메시지를 가져온다.\n            let message = this.messageCache[ev.button];\n            delete this.messageCache[ev.button];\n            if (message) {\n                message.endX = x;\n                message.endY = y;\n                message.endTime = ev.timeStamp;\n                this.push(message);\n                this.point.input(x, y);\n            }\n        };\n    }\n    /** 입력 컴포넌트를 뷰에 연결한다. */\n    connect(source, listener) {\n        this.disconnect();\n        this.source = source;\n        this.listener = listener;\n        this.source.addEventListener('mousedown', this.onstart);\n        this.source.addEventListener('mousemove', this.onmove);\n        document.addEventListener('mouseup', this.onend);\n    }\n    /** 입력 컴포넌트 연결을 해제한다. */\n    disconnect() {\n        let source = this.source;\n        if (source) {\n            source.removeEventListener('mousedown', this.onstart);\n            source.removeEventListener('mousemove', this.onmove);\n            document.removeEventListener('mouseup', this.onend);\n        }\n        this.source = null;\n        this.listener = null;\n    }\n    /**\n     * (rAF) 큐에 있는 메시지를 모두 정리하고, 상태를 전이시킨다.\n     *\n     * # 중요 : 메시지 큐, 메시지 버퍼에 쌓인 것들은 rAF와 독립적으로 발생한 것들이다. 따라서 메시지는 pointState와는 좆도 상관없다.\n     * */\n    update() {\n        this.dispatchAll();\n        this.point.pulse();\n        if (this.buttons)\n            this.listener.onPointMove(this.point);\n    }\n}\n/**\n * 터치 입력을 받아들여 메시지를 처리하고 리스너에게 전달하는 컴포넌트\n *\n * 이 객체는 터치 움직임에 따라 이전 위치를 저장하여 터치의 움직임을 추적할 수 있으며, requestAnimationFrame()을 사용한 업데이트 패턴에 특화된 구조를 가지고 있다.\n *\n * MouseInput 객체와 거의 같으나 아주 미세한 곳에서 차이가 있다.\n *\n * 1. 터치 입력을 받아들인다. 물론 붙이는 리스너도 touchstart, touchend로 결정된다.\n * 2. 터치 이벤트의 구조가 다르다. 터치는 여러 개가 있을 수 있고, 마우스와 달리 모두 다른 곳에 위치해 있을 수 있다.\n */\nclass TouchInput extends PointMessageQueue {\n    constructor() {\n        super(...arguments);\n        this.messageCache = [];\n        /**\n         * 마우스는 항상 하나의 좌표지만 터치는 언제 어디서 어떤 터치가 생길지, 없어질지 모른다.\n         * 근데 메인 터치는 있어야 하는 법이고, 갑자기 메인 터치가 없어지면 여기 있던 놈들 중에서 한 녀석이 메인 터치를 계승한다.\n         * */\n        this.touchStateMap = [];\n        /** @private 메인 터치의 위치 */\n        this._point = null;\n        this.onstart = (ev) => {\n            // 이게 없을 때 캔버스를 스와이프하면 페이지가 스크롤되고 탭을 하면 일부 환경에서 mouseup,mousedown을 일으킨다.\n            // 타겟이 도큐먼트가 아니라면 스크롤되어선 안되겠지?\n            ev.preventDefault();\n            const startTime = ev.timeStamp;\n            let touchList = ev.changedTouches;\n            for (const touch of touchList) {\n                let startX = (touch.pageX - this.sourceLeft);\n                let startY = (touch.pageY - this.sourceTop);\n                let id = touch.identifier;\n                let state = new PointState();\n                state.input(startX, startY);\n                state.shim(startX, startY);\n                this.touchStateMap[id] = state;\n                // 메인 터치가 없었다면 이 터치를 메인 터치로 설정한다.\n                if (!this.point)\n                    this._point = state;\n                this.push({ type: \"touchstart\", id, startX, startY, startTime });\n                this.messageCache[id] = { type: \"touchend\", id, startX, startY, startTime };\n            }\n            return false;\n        };\n        this.onmove = (ev) => {\n            for (const touch of ev.changedTouches) {\n                if (touch.identifier in this.touchStateMap) {\n                    const state = this.touchStateMap[touch.identifier];\n                    let x = (touch.pageX - this.sourceLeft);\n                    let y = (touch.pageY - this.sourceTop);\n                    state.input(x, y);\n                }\n            }\n        };\n        this.onend = (ev) => {\n            for (const touch of ev.changedTouches) {\n                if (touch.identifier in this.touchStateMap) {\n                    const message = this.messageCache[touch.identifier];\n                    delete this.messageCache[touch.identifier];\n                    if (message) {\n                        const state = this.touchStateMap[touch.identifier];\n                        const x = (touch.pageX - this.sourceLeft);\n                        const y = (touch.pageY - this.sourceTop);\n                        message.endX = x;\n                        message.endY = y;\n                        message.endTime = ev.timeStamp;\n                        this.push(message);\n                        state.input(x, y);\n                        // 놓은 위치의 터치 위치 상태를 뺀다.\n                        delete this.touchStateMap[touch.identifier];\n                        // 메이저 터치가 빠졌으면 후계자를 찾는다.\n                        if (this.point == state) {\n                            this._point = null;\n                            for (const i in this.touchStateMap) {\n                                if (this.touchStateMap.hasOwnProperty(i)) {\n                                    this._point = this.touchStateMap[i];\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    }\n    /** @readonly 메인 터치의 위치 */\n    get point() { return this._point; }\n    ;\n    connect(source, listener) {\n        this.disconnect();\n        this.source = source;\n        this.listener = listener;\n        this.source.addEventListener('touchstart', this.onstart);\n        this.source.addEventListener('touchmove', this.onmove);\n        document.addEventListener('touchend', this.onend);\n        let { left, top } = source.getBoundingClientRect();\n        this.sourceLeft = left;\n        this.sourceTop = top;\n    }\n    disconnect() {\n        let source = this.source;\n        if (source) {\n            source.removeEventListener('touchstart', this.onstart);\n            source.removeEventListener('touchmove', this.onmove);\n            document.removeEventListener('touchend', this.onend);\n        }\n        this.source = null;\n        this.listener = null;\n    }\n    update() {\n        this.dispatchAll();\n        for (const i in this.touchStateMap)\n            this.touchStateMap[i].pulse();\n        if (this._point)\n            this.listener.onPointMove(this._point);\n    }\n}\n\n\n//# sourceURL=webpack:///./app/Input.ts?");

/***/ }),

/***/ "./app/Matrix2D.ts":
/*!*************************!*\
  !*** ./app/Matrix2D.ts ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Matrix2D; });\n/**\n * 이렇게 생긴 행렬을 나타낸다:\n *\n * ````plaintext\n * a 0 e\n * 0 d f\n * 0 0 1\n * ````\n * skew는 고려대상이 아니므로 b, c는 뺐다.\n */\nclass Matrix2D {\n    constructor(a, d, e, f) {\n        this.a = 1;\n        this.d = 1;\n        this.e = 0;\n        this.f = 0;\n        this.a = a;\n        this.d = d;\n        this.e = e;\n        this.f = f;\n    }\n    /** 모델 상에서의 어떤 지점이 뷰에 나타나는 위치 */\n    transformPoint(x, y) {\n        let { a, d, e, f } = this;\n        return [x * a + e, y * d + f];\n    }\n    /** 뷰의 어떤 지점을 찍었을 때 그 점의 모델 상에서의 위치 */\n    itransformPoint(x, y) {\n        let { a, d, e, f } = this;\n        return [(x - e) / a, (y - f) / d];\n    }\n    /** 모델 상의 두 지점이 뷰에 나타날 때 두 점의 변위의 각 성분 */\n    transformDimension(w, h) {\n        let { a, d } = this;\n        return [w * a, h * d];\n    }\n    /** 뷰에 나타난 변위의 각 성분의 모델에서의 길이 */\n    itransformDimension(w, h) {\n        let { a, d } = this;\n        return [w / a, h / d];\n    }\n}\n\n\n//# sourceURL=webpack:///./app/Matrix2D.ts?");

/***/ }),

/***/ "./app/Moving.ts":
/*!***********************!*\
  !*** ./app/Moving.ts ***!
  \***********************/
/*! exports provided: Moving */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Moving\", function() { return Moving; });\nconst stopVel = 0.001;\nconst initState = {\n    x: 0,\n    y: 0,\n    velX: 0,\n    velY: 0\n};\nclass Moving {\n    constructor(maxSpeed, acc, closeDistance) {\n        this.x = 0;\n        this.y = 0;\n        this.velX = 0;\n        this.velY = 0;\n        this.destX = null;\n        this.destY = null;\n        this.updateVel = this.friction;\n        this.maxSpeed = maxSpeed;\n        this.acc = acc;\n        this.closeDistance = closeDistance;\n    }\n    moveToTarget() {\n        const { x, y, velX, velY, destX, destY, maxSpeed, closeDistance, acc } = this;\n        let dx = destX - x;\n        let dy = destY - y;\n        if (dx != 0 || dy != 0) {\n            let angle = Math.atan2(dy, dx);\n            let targetVelX = Math.cos(angle) * maxSpeed;\n            let targetVelY = Math.sin(angle) * maxSpeed;\n            let distance = Math.hypot(dx, dy);\n            if (distance < closeDistance) {\n                targetVelX *= distance / closeDistance;\n                targetVelY *= distance / closeDistance;\n            }\n            let dVelX = targetVelX - velX;\n            let dVelY = targetVelY - velY;\n            this.velX += Math.sign(dVelX) * Math.min(Math.abs(dVelX), acc);\n            this.velY += Math.sign(dVelY) * Math.min(Math.abs(dVelY), acc);\n        }\n    }\n    friction() {\n        if (Math.abs(this.velX) < stopVel)\n            this.velX = 0;\n        else\n            this.velX *= 0.9;\n        if (Math.abs(this.velY) < stopVel)\n            this.velY = 0;\n        else\n            this.velY *= 0.9;\n    }\n    init() {\n        Object.assign(this, initState);\n        this.removeDestination();\n    }\n    setDestination(x, y) {\n        this.destX = x;\n        this.destY = y;\n        this.updateVel = this.moveToTarget;\n    }\n    removeDestination() {\n        this.destX = null;\n        this.destY = null;\n        this.updateVel = this.friction;\n    }\n    update() {\n        this.updateVel();\n        this.x += this.velX;\n        this.y += this.velY;\n    }\n}\n// export function moveToTarget(this : DesiredPhysical, maxSpeed : number, acc : number, closeDistance : number) {\n// \tlet { x, y, velX, velY, destX, destY } = this;\n// \tlet dx = destX - x;\n// \tlet dy = destY - y;\n// \tif (dx != 0 || dy != 0) {\n// \t\tlet angle = Math.atan2(dy, dx);\n// \t\tlet targetVelX = Math.cos(angle) * maxSpeed;\n// \t\tlet targetVelY = Math.sin(angle) * maxSpeed;\n// \t\tlet distance = Math.hypot(dx, dy);\n// \t\tif (distance < closeDistance) {\n// \t\t\ttargetVelX *= distance / closeDistance;\n// \t\t\ttargetVelY *= distance / closeDistance;\n// \t\t}\n// \t\tlet dVelX = targetVelX - velX;\n// \t\tlet dVelY = targetVelY - velY;\n// \t\tthis.velX += Math.sign(dVelX) * Math.min(Math.abs(dVelX), acc);\n// \t\tthis.velY += Math.sign(dVelY) * Math.min(Math.abs(dVelY), acc);\n// \t}\n// }\n// export function friction(this : DesiredPhysical, stopVel = 0.001) {\n// \tthis.velX *= 0.9;\n// \tif (Math.abs(this.velX) < stopVel) this.velX = 0;\n// \tthis.velY *= 0.9;\n// \tif (Math.abs(this.velY) < stopVel) this.velY = 0;\n// }\n\n\n//# sourceURL=webpack:///./app/Moving.ts?");

/***/ }),

/***/ "./app/RAFPulseClock.ts":
/*!******************************!*\
  !*** ./app/RAFPulseClock.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return RAFPulseClock; });\nclass RAFPulseClock {\n    constructor(update) {\n        this.a = null;\n        this.update = update;\n    }\n    start() {\n        this.a = (t) => {\n            this.update(t);\n            requestAnimationFrame(this.a);\n        };\n        requestAnimationFrame(this.a);\n    }\n    end() {\n        this.a = (t) => {\n            this.a = null;\n        };\n    }\n}\n\n\n//# sourceURL=webpack:///./app/RAFPulseClock.ts?");

/***/ }),

/***/ "./app/Thing.ts":
/*!**********************!*\
  !*** ./app/Thing.ts ***!
  \**********************/
/*! exports provided: hit, Enemy, Tuna */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hit\", function() { return hit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Enemy\", function() { return Enemy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tuna\", function() { return Tuna; });\nfunction hit(a, b) {\n    let { x: ax, y: ay, size: ar } = a;\n    let { x: bx, y: by, size: br } = b;\n    const dist = ar + br;\n    return Math.abs(ax - bx) < dist\n        && Math.abs(ay - by) < dist\n        && Math.hypot(ax - bx, ay - by) < ar + br;\n}\nclass Enemy {\n    constructor(type, x, y, angle, profile) {\n        this.profile = profile;\n        this.type = type;\n        this.x = x;\n        this.y = y;\n        const diverge = (Math.random() - 0.5) * profile.diverge;\n        this.velX = -Math.cos(angle + diverge) * profile.speed;\n        this.velY = -Math.sin(angle + diverge) * profile.speed;\n        this.life = profile.life;\n    }\n    get valid() { return this.life > 0; }\n    get size() { return this.profile.size; }\n    update(game) {\n        this.x += this.velX;\n        this.y += this.velY;\n        this.life--;\n    }\n    renderHitbox(context) {\n        let { x, y, profile } = this;\n        let { size, color } = profile;\n        context.strokeStyle = color;\n        context.lineWidth = 1;\n        context.beginPath();\n        context.ellipse(x, y, size, size, 0, 0, Math.PI * 2);\n        context.stroke();\n    }\n    dispose() {\n        this.life = 0;\n    }\n}\nconst tunaLife = 1800;\nconst tunaColor = \"#FFBF00\";\nconst tunaSize = 4;\nclass Tuna {\n    constructor(x, y) {\n        this.life = tunaLife;\n        this.x = x;\n        this.y = y;\n    }\n    get size() { return tunaSize; }\n    get valid() { return this.life > 0; }\n    update(game) {\n        this.life--;\n    }\n    renderHitbox(context) {\n        context.strokeStyle = tunaColor;\n        context.lineWidth = 1;\n        context.beginPath();\n        context.ellipse(this.x, this.y, tunaSize, tunaSize, 0, 0, Math.PI * 2);\n        context.stroke();\n    }\n    dispose() {\n        this.life = 0;\n    }\n}\n\n\n//# sourceURL=webpack:///./app/Thing.ts?");

/***/ }),

/***/ "./app/Timer.ts":
/*!**********************!*\
  !*** ./app/Timer.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Timer; });\n/** 마이크로초를 mm : ss . ss 로 나눈다. */\nfunction formatMs(ms) {\n    let val = Math.round(ms / 10);\n    let min = Math.floor(val / 6000);\n    let centisec = val % 6000;\n    let centisec_str = centisec.toString();\n    let centisec_len = centisec_str.length;\n    if (centisec_len < 4) {\n        let a = Array(4 - centisec_len);\n        a.fill('0');\n        centisec_str = a.join('') + centisec_str;\n    }\n    let min_str = min.toString();\n    let min_len = min_str.length;\n    if (min_len < 2) {\n        let a = Array(2 - min_len);\n        a.fill('0');\n        min_str = a.join('') + min_str;\n    }\n    return [min_str, centisec_str.substr(0, 2), centisec_str.substr(2, 2)];\n}\nconst timerWidth = 56;\nconst w_3 = timerWidth / 3;\nconst w_6 = timerWidth / 6;\nconst timerFontSize = 12;\n/**\n * 타이머 컴포넌트\n * DOMHighResTimestamp 때문에 로직이 은근 복잡하다.\n * */\nclass Timer {\n    constructor() {\n        /** 시작 버튼을 누른 시각 */\n        this.startTime = null;\n        /** 퍼즐이 중단된 시각 */\n        this.endTime = null;\n        /** rAF에 의해 입력되는 시각 */\n        this.currentTime = 0;\n    }\n    start(startTime) {\n        this.startTime = startTime;\n        this.endTime = null;\n    }\n    end(endTime) {\n        this.endTime = endTime;\n    }\n    reset() {\n        this.startTime = null;\n        this.endTime = null;\n        this.currentTime = null;\n    }\n    update(t) {\n        this.currentTime = t;\n    }\n    render(context, x, y) {\n        let left = x - timerWidth / 2;\n        context.font = timerFontSize + 'px \"Exo 2\"';\n        let [min, sec, cs] = formatMs(this.currentTime - this.startTime);\n        context.fillText(min, left + w_6, y);\n        context.fillText('\\'', left + w_3, y);\n        context.fillText('\"', left + w_3 * 2, y);\n        context.textAlign = 'right';\n        context.fillText(sec[0], left + w_3 + w_6, y);\n        context.fillText(cs[0], left + w_3 * 2 + w_6, y);\n        context.textAlign = 'left';\n        context.fillText(sec[1], left + w_3 + w_6, y);\n        context.fillText(cs[1], left + w_3 * 2 + w_6, y);\n    }\n}\n\n\n//# sourceURL=webpack:///./app/Timer.ts?");

/***/ }),

/***/ "./app/View.ts":
/*!*********************!*\
  !*** ./app/View.ts ***!
  \*********************/
/*! exports provided: Viewbox, View */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Viewbox\", function() { return Viewbox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"View\", function() { return View; });\n/* harmony import */ var _Matrix2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix2D */ \"./app/Matrix2D.ts\");\n\nclass Viewbox {\n    constructor(view, context, rWidth, rHeight) {\n        this.view = view;\n        this.context = context;\n        let { a, d, e, f } = this.context.getTransform();\n        this.matrix = new _Matrix2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"](a, d, e, f);\n        this._width = rWidth / a;\n        this._height = rHeight / d;\n        this._left = -e;\n        this._top = -f;\n    }\n    get left() { return this._left; }\n    get top() { return this._top; }\n    get width() { return this._width; }\n    get height() { return this._height; }\n    get x() { return this._left + this._width / 2; }\n    get y() { return this._top + this._height / 2; }\n    get right() { return this._left + this._width; }\n    get bottom() { return this._top + this._height; }\n    /** 뷰박스의 가운데가 지정한 좌표값이 되도록 뷰박스를 이동시킨다. */\n    setPosition(x = null, y = null) {\n        const matrix = this.matrix;\n        let { a, d } = matrix;\n        if (x != null)\n            this._left = x - this._width / 2;\n        if (y != null)\n            this._top = y - this._height / 2;\n        matrix.e = -this._left * a;\n        matrix.f = -this._top * d;\n        this.context.setTransform(a, 0, 0, d, matrix.e, matrix.f);\n    }\n    /** 뷰박스를 이동시킨다.\n     * 신기하게도 Context.translate는 입력값 만큼만 변환시키는 것이 아니라 변환행렬의 다른 값들이 함께 적용된다. */\n    move(dx, dy) {\n        const matrix = this.matrix;\n        matrix.e += -dx * matrix.a;\n        matrix.f += -dy * matrix.d;\n        this._left += dx;\n        this._top += dy;\n        this.context.translate(-dx, -dy);\n    }\n    /**\n     * 뷰박스의 크기를 설정한다.\n     * height가 없으면 __뷰(캔버스)의 종횡 비율__이 적용된다.\n     * 아무런 인수가 없으면 기존의 width가 적용된다.\n     * */\n    setSize(width, height) {\n        let { x, y } = this;\n        (width != null) ? this._width = width : width = this._width;\n        if (height == null)\n            height = width * this.view.height / this.view.width;\n        this._height = height;\n        this._left = x - width / 2;\n        this._top = y - height / 2;\n        let a = this.view.width / width;\n        let d = this.view.height / height;\n        let e = -this._left * a;\n        let f = -this._top * d;\n        Object.assign(this.matrix, { a, d, e, f });\n        this.context.setTransform(a, 0, 0, d, e, f);\n    }\n}\n/**\n * 기본적으로는 캔버스와 같으나, 뷰포트(Viewport)를 고려하여 크기 조절 시 컨텍스트의 변환 행렬을 조절하는 기능을 추가로 갖고 있다. 이러한 사양 때문에 실제 크기 속성을 함께 가지고 있다.\n */\nclass View {\n    /**\n     * 캔버스를 기반으로 뷰를 생성한다.\n     * 기존에 설정되어 있던 변환행렬을 기반으로 위치, 배율이 현재 객체에 자동으로 등록된다.\n     */\n    constructor(canvas) {\n        this.canvas = canvas;\n        this.context = canvas.getContext('2d', { alpha: false });\n        this.realWidth = this.canvas.width;\n        this.realHeight = this.canvas.height;\n        this.viewbox = new Viewbox(this, this.context, this.realWidth, this.realHeight);\n    }\n    get width() { return this.realWidth; }\n    get height() { return this.realHeight; }\n    /**\n     * 뷰(캔버스)의 크기를 변경하고, 뷰박스 크기는 변경되지 않도록 context의 변환행렬 값을 적절한 것으로 채워 넣는다.\n     * height가 없으면 현재 뷰(캔버스)의 width 변화에 비례한 값이 자동 설정된다.\n     * */\n    setViewSize(width, height) {\n        if (height == null)\n            height = width * this.realHeight / this.realWidth;\n        this.realWidth = width;\n        this.realHeight = height;\n        this.canvas.width = width;\n        this.canvas.height = height;\n        this.viewbox.setSize();\n    }\n    /** 뷰가 지금 보고 있는 곳(뷰박스)을 청소한다. */\n    clearRect() {\n        const { left, top, width, height } = this.viewbox;\n        this.context.clearRect(left - 5, top - 5, width + 10, height + 10);\n    }\n}\n\n\n//# sourceURL=webpack:///./app/View.ts?");

/***/ }),

/***/ "./app/You.ts":
/*!********************!*\
  !*** ./app/You.ts ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return You; });\n/* harmony import */ var _Moving__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Moving */ \"./app/Moving.ts\");\n\nconst yourColor = \"#FFFF00\";\nconst yourMaxSpeed = 0.9;\nconst yourAcc = 0.5;\nconst closeDistance = 10;\nconst yourSize = 5;\nconst yourLife = 1800;\nconst yourHealth = 6;\nconst sight = 120;\nconst backgroundColor = [41 / 255, 43 / 255, 44 / 255];\nconst lightColorSource0 = [149 / 255, 232 / 255, 1];\nconst lightColorSource1 = [16 / 255, 90 / 255, 136 / 255];\nconst lightMinRange = 25;\nconst lightMaxRange = 150;\nfor (let i = 0; i < 3; i++) {\n    lightColorSource0[i] = Math.floor(lightColorSource0[i] * backgroundColor[i]);\n    lightColorSource1[i] = Math.floor(lightColorSource1[i] * backgroundColor[i]);\n}\nconst sightColorStop0 = `rgba(${lightColorSource0[0]}, ${lightColorSource0[1]}, ${lightColorSource0[2]}, 0)`;\nconst sightColorStop1 = `rgba(${lightColorSource1[0]}, ${lightColorSource1[1]}, ${lightColorSource1[2]}, 0.5)`;\nconst sightColorStop2 = \"#000000FF\";\n// 참고 : Life는 수명이고 Health는 체력이다. 시간이 흐르면 Life가 깎이고, 철충한테 맞으면 Health가 깎인다.\nclass You {\n    constructor() {\n        this.sight = sight;\n        this.moving = new _Moving__WEBPACK_IMPORTED_MODULE_0__[\"Moving\"](yourMaxSpeed, yourAcc, closeDistance);\n        this.init();\n    }\n    get valid() { return this.life > 0 && this.health > 0; }\n    get x() { return this.moving.x; }\n    get y() { return this.moving.y; }\n    get size() { return yourSize; }\n    /** 너를 처음 상태로 만든다. */\n    init() {\n        this.life = yourLife;\n        this.maxLife = yourLife;\n        this.health = yourHealth;\n        this.maxHealth = yourHealth;\n        this.moving.init();\n    }\n    update(game) {\n        this.moving.update();\n    }\n    drain() {\n        this.life--;\n    }\n    dispose() {\n        this.life = 0;\n    }\n    renderHitbox(context) {\n        context.strokeStyle = yourColor;\n        context.lineWidth = 1;\n        context.beginPath();\n        context.ellipse(this.x, this.y, yourSize, yourSize, 0, 0, Math.PI * 2);\n        context.stroke();\n    }\n    renderSprite(context) {\n        // context.drawImage(yourImage, this.x - 18, this.y - 27, 36, 54);\n    }\n    renderLight(context) {\n        const { x, y, sight } = this;\n        let grad = context.createRadialGradient(x, y, lightMinRange, x, y, lightMaxRange);\n        grad.addColorStop(0.0, sightColorStop0);\n        grad.addColorStop(0.5, sightColorStop1);\n        grad.addColorStop(1.0, sightColorStop2);\n        context.fillStyle = grad;\n        context.fillRect(x - 500, y - 500, 1000, 1000);\n    }\n    renderLife(context, x, y, distance) {\n        distance -= 2.5;\n        let startAngle = Math.PI * 5 / 6;\n        let { life, maxLife } = this;\n        let ratio = Math.max(0, life / maxLife);\n        let endAngle = startAngle + Math.PI * ratio / 3;\n        context.lineWidth = 5;\n        context.strokeStyle = \"hsla(45, 100%, 75%, 0.25)\";\n        context.beginPath();\n        context.ellipse(x, y, distance, distance, 0, startAngle, endAngle);\n        context.stroke();\n    }\n    renderHealth(context, x, y, distance) {\n        distance -= 2.5;\n        let startAngle = Math.PI / 6;\n        let { health, maxHealth } = this;\n        let ratio = Math.max(0, health / maxHealth);\n        let endAngle = startAngle - Math.PI * ratio / 3;\n        context.lineWidth = 5;\n        context.strokeStyle = \"hsla(200, 100%, 70%, 0.25)\";\n        const hopAngle = Math.PI / 3 / maxHealth;\n        const unitAngle = hopAngle * 4 / 5;\n        for (let i = 0; i < health; i++) {\n            const angle = startAngle - hopAngle * i;\n            context.beginPath();\n            context.ellipse(x, y, distance, distance, 0, angle, angle - unitAngle, true);\n            context.stroke();\n        }\n    }\n    renderYourUI(context, x, y, distance) {\n        this.renderLife(context, x, y, distance);\n        this.renderHealth(context, x, y, distance);\n    }\n}\n\n\n//# sourceURL=webpack:///./app/You.ts?");

/***/ }),

/***/ "./app/index.ts":
/*!**********************!*\
  !*** ./app/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _View__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./View */ \"./app/View.ts\");\n/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Input */ \"./app/Input.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Game */ \"./app/Game.ts\");\n/* harmony import */ var _RAFPulseClock__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RAFPulseClock */ \"./app/RAFPulseClock.ts\");\n\n\n\n\nconst gameElement = document.getElementById('game-frame');\ngameElement.addEventListener('contextmenu', ev => {\n    ev.preventDefault();\n    return false;\n}, { capture: true });\nconst gameCanvas = document.getElementById('game-canvas');\ngameCanvas.getContext('2d').setTransform(1, 0, 0, 1, gameCanvas.width / 2, gameCanvas.height / 2);\nconst uiCanvas = document.getElementById('ui-canvas');\nuiCanvas.getContext('2d').setTransform(1, 0, 0, 1, uiCanvas.width / 2, uiCanvas.height / 2);\nconst gameView = new _View__WEBPACK_IMPORTED_MODULE_0__[\"View\"](gameCanvas);\ngameView.context.imageSmoothingEnabled = false;\nconst uiView = new _View__WEBPACK_IMPORTED_MODULE_0__[\"View\"](uiCanvas);\nconst game = new _Game__WEBPACK_IMPORTED_MODULE_2__[\"default\"](gameView.viewbox);\nconst input = new _Input__WEBPACK_IMPORTED_MODULE_1__[\"MouseInput\"]();\ninput.connect(gameElement, game);\nfunction fitSize() {\n    let w, h;\n    let viewRatio = gameView.width / gameView.height;\n    if (window.innerWidth / window.innerHeight > viewRatio) {\n        h = window.innerHeight;\n        w = h * viewRatio;\n    }\n    else {\n        w = window.innerWidth;\n        h = w / viewRatio;\n    }\n    gameElement.style.cssText = `width:${w}px;height:${h}px;`;\n    gameView.setViewSize(w);\n    uiView.setViewSize(w);\n}\nwindow.addEventListener('resize', fitSize);\nwindow.addEventListener('load', fitSize);\nconst gridStep = 20;\nfunction renderGrid(view) {\n    let { viewbox, context } = view;\n    const { left, right, top, bottom } = viewbox;\n    const startX = (Math.round(left / gridStep) - 1) * gridStep;\n    const startY = (Math.round(top / gridStep) - 1) * gridStep;\n    const endX = (Math.round(right / gridStep) + 1) * gridStep;\n    const endY = (Math.round(bottom / gridStep) + 1) * gridStep;\n    context.fillStyle = \"#80808040\";\n    for (let x = startX; x < endX; x += gridStep) {\n        for (let y = startY; y < endY; y += gridStep) {\n            context.fillRect(x - 1, y - 1, 2, 2);\n        }\n    }\n    // context.fillStyle = \"#80808020\";\n    // for (let x = startX; x < endX; x += gridStep) {\n    // \tfor (let y = startY; y < endY; y += gridStep) {\n    // \t\tlet x_ = x + (x - viewboxX) / 10;\n    // \t\tlet y_ = y + (y - viewboxY) / 10;\n    // \t\tcontext.fillRect(x_ - 2, y_ - 2, 4, 4);\n    // \t}\n    // }\n}\nconst clock = new _RAFPulseClock__WEBPACK_IMPORTED_MODULE_3__[\"default\"](t => {\n    input.update();\n    game.hitTest();\n    game.update(t);\n    gameView.clearRect();\n    renderGrid(gameView);\n    game.render(gameView.context);\n    uiView.clearRect();\n    game.renderUI(uiView.context);\n});\nclock.start();\n\n\n//# sourceURL=webpack:///./app/index.ts?");

/***/ })

/******/ });