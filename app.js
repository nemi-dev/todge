/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./app/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./app/Game.ts":
/*!*********************!*\
  !*** ./app/Game.ts ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Game; });\n/* harmony import */ var _Thing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Thing */ \"./app/Thing.ts\");\n/* harmony import */ var _You__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./You */ \"./app/You.ts\");\n/* harmony import */ var _Moving__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Moving */ \"./app/Moving.ts\");\n/* harmony import */ var _Timer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Timer */ \"./app/Timer.ts\");\n\r\n\r\n\r\n\r\nconst maxSpawnDelay = 160;\r\nconst minSpawnCount = 1;\r\nconst varSpawnCount = 10;\r\nconst maxTunaDelay = 900;\r\nconst enemySpeed = 1.2;\r\nconst enemySize = 5;\r\nconst tunaSize = 4;\r\nconst followDistance = 30;\r\nconst timerWidth = 56;\r\nconst timerHeight = 12;\r\nconst textMaxLife = 30;\r\nconst damage = 20;\r\nclass GuideText {\r\n    constructor(text, x, y, size, weight) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.text = text;\r\n        this.size = size;\r\n        this.fontWeight = weight;\r\n    }\r\n    render(context, a) {\r\n        let { x, y, text } = this;\r\n        context.fillStyle = `hsla(196, 100%, 71%, ${a})`;\r\n        context.textAlign = \"center\";\r\n        context.textBaseline = \"middle\";\r\n        context.font = `${this.fontWeight} ${this.size}px \"Exo 2\", \"Noto Sans KR\"`;\r\n        context.fillText(text, x, y);\r\n    }\r\n}\r\nclass Game {\r\n    constructor(viewbox) {\r\n        this.messages = [];\r\n        this.torusWidth = 220;\r\n        this.torusHeight = 280;\r\n        this.removeUpdateFunctionLater = [];\r\n        this.updateFunctionLater = [];\r\n        this.onstart = this._onStartInitial;\r\n        let you = new _You__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\r\n        let viewboxReplica = {\r\n            x: 0,\r\n            y: 0,\r\n            velX: 0,\r\n            velY: 0,\r\n            destX: 0,\r\n            destY: 0\r\n        };\r\n        this.you = you;\r\n        this.viewbox = viewbox;\r\n        this.mat = viewbox.matrix;\r\n        this.guideTexts = [\r\n            new GuideText(\"땃~쥐!\", 0, -followDistance * 2, 20, \"bold\"),\r\n            new GuideText(\"Todge\", 0, -followDistance * 2 + 15, 12, \"bold\"),\r\n            new GuideText(\"참치캔 게이지\", -followDistance * 2.5, -12, 10, \"bold\"),\r\n            new GuideText(\"시간마다 조금씩 감소\", -followDistance * 2.5, 0, 7, \"normal\"),\r\n            new GuideText(\"참치캔을 먹어서 회복\", -followDistance * 2.5, 8, 7, \"normal\"),\r\n            new GuideText(\"체력 게이지\", followDistance * 2.5, 0, 10, \"bold\"),\r\n            new GuideText(\"길게 눌러 이동\", 0, followDistance * 2, 10, \"bold\"),\r\n            new GuideText(\"가까운 지점을 누르면 느리게 이동\", 0, followDistance * 2 + 10, 7, \"normal\"),\r\n        ];\r\n        this.viewboxReplica = viewboxReplica;\r\n        this.moveViewboxToTarget = _Moving__WEBPACK_IMPORTED_MODULE_2__[\"moveToTarget\"].bind(viewboxReplica, you.speed, you.acc, you.closeDistance);\r\n        this.viewboxFriction = _Moving__WEBPACK_IMPORTED_MODULE_2__[\"friction\"].bind(viewboxReplica);\r\n        this.timer = new _Timer__WEBPACK_IMPORTED_MODULE_3__[\"default\"](timerWidth, timerHeight);\r\n        this.init(0);\r\n    }\r\n    /** 게임을 처음 상태 (대기 상태)로 돌린다. */\r\n    init(t) {\r\n        this.status = \"free\";\r\n        this.you.init();\r\n        this.enemies = [];\r\n        this.tunas = [];\r\n        this.updateFunctions = [this._update_you, this._you_are_invincible];\r\n        this.viewbox.setPosition(0, 0);\r\n        const viewboxReplica = this.viewboxReplica;\r\n        viewboxReplica.x = 0;\r\n        viewboxReplica.y = 0;\r\n        viewboxReplica.velX = 0;\r\n        viewboxReplica.velY = 0;\r\n        viewboxReplica.destX = 0;\r\n        viewboxReplica.destY = 0;\r\n        this.guideLife = textMaxLife;\r\n        this.onstart = this._onStartInitial;\r\n        this.enemySpawnCounter = 0;\r\n        this.totalEnemiesNumber = 0;\r\n        this.currentEnemiesNumber = 0;\r\n        this.tunaSpawnCounter = 0;\r\n        this.timer.startTime = t;\r\n        this.timer.currentTime = t;\r\n    }\r\n    /** 게임 시작을 알리는 메서드 */\r\n    start(t) {\r\n        this.status = \"start\";\r\n        // 무적을 뺀다.\r\n        this.updateFunctions.pop();\r\n        this.updateFunctions.push(this._update_guide, this._update_things, this._update_timer);\r\n        this.timer.start(t);\r\n        this.onstart = this._onstart;\r\n    }\r\n    /** 게임 오버를 알리는 메서드 */\r\n    gameover(t) {\r\n        this.status = \"dead\";\r\n        this.timer.end(t);\r\n        this.updateFunctions = [];\r\n        this.onstart = this._onstartDead;\r\n    }\r\n    push(m) {\r\n        this.messages.unshift(m);\r\n    }\r\n    dispatchAll() {\r\n        let m;\r\n        while ((m = this.messages.pop()) != null) {\r\n            switch (m.type) {\r\n                case \"mousedown\":\r\n                    this.onstart(m);\r\n                    break;\r\n                case \"mouseup\":\r\n                    this.onend(m);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    createThingRandom() {\r\n        const chance = Math.pow(this.enemySpawnCounter / (maxSpawnDelay + 1), 2);\r\n        const { x: yourX, y: yourY, sight } = this.you;\r\n        const { enemies, tunas } = this;\r\n        if (Math.random() < chance) {\r\n            const count = Math.floor(Math.random() * varSpawnCount) + minSpawnCount;\r\n            for (let i = 0; i < count; i++) {\r\n                let angle = Math.random() * Math.PI * 2;\r\n                let diverge = (Math.random() - 0.5) * Math.PI / 2;\r\n                let distance = sight * 1.5;\r\n                let x = yourX + Math.cos(angle) * distance;\r\n                let y = yourY + Math.sin(angle) * distance;\r\n                const thing = new _Thing__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"enemy\", x, y, enemySize, \"#FF0000\", 600);\r\n                thing.velX = -enemySpeed * Math.cos(angle + diverge);\r\n                thing.velY = -enemySpeed * Math.sin(angle + diverge);\r\n                enemies.push(thing);\r\n                this.enemySpawnCounter = 0;\r\n                this.totalEnemiesNumber++;\r\n                this.currentEnemiesNumber++;\r\n            }\r\n        }\r\n        this.enemySpawnCounter++;\r\n        const tunaChance = this.tunaSpawnCounter / maxTunaDelay - 0.3;\r\n        if (Math.random() < tunaChance / 20) {\r\n            let angle = Math.random() * Math.PI * 2;\r\n            let distance = sight * (0.5 + Math.random());\r\n            let x = yourX + Math.cos(angle) * distance;\r\n            let y = yourY + Math.sin(angle) * distance;\r\n            const thing = new _Thing__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\"tuna\", x, y, tunaSize, \"#FFB300\", 1800);\r\n            tunas.push(thing);\r\n            this.tunaSpawnCounter = 0;\r\n        }\r\n        else {\r\n            this.tunaSpawnCounter++;\r\n        }\r\n    }\r\n    /** 아직 게임이 시작되지 않았을 때 마우스 누름/터치 시작 핸들러 */\r\n    _onStartInitial(m) {\r\n        this.you.setDestination(...this.mat.itransformPoint(m.startX, m.startY));\r\n        this.start(m.startTime);\r\n    }\r\n    /** 게임 플레이 중 누름 핸들러 */\r\n    _onstart(m) {\r\n        this.you.setDestination(...this.mat.itransformPoint(m.startX, m.startY));\r\n    }\r\n    /** 게임오버 되었을 때 누름 핸들러 */\r\n    _onstartDead(m) {\r\n        this.init(m.startTime);\r\n    }\r\n    onend(m) {\r\n        this.you.neutralizeDestination();\r\n    }\r\n    dispatchDrag(c) {\r\n        let [x, y] = this.mat.itransformPoint(c.x, c.y);\r\n        this.you.setDestination(x, y);\r\n    }\r\n    moveViewboxToYou() {\r\n        const replica = this.viewboxReplica;\r\n        let viewDistX = this.you.x - this.viewbox.x;\r\n        let viewDistY = this.you.y - this.viewbox.y;\r\n        let distance = Math.hypot(viewDistX, viewDistY);\r\n        if (distance > followDistance) {\r\n            replica.destX = this.you.x;\r\n            replica.destY = this.you.y;\r\n            this.moveViewboxToTarget();\r\n        }\r\n        else {\r\n            this.viewboxFriction();\r\n        }\r\n        replica.x += replica.velX;\r\n        replica.y += replica.velY;\r\n        this.viewbox.move(replica.velX, replica.velY);\r\n    }\r\n    _update_you(t) {\r\n        this.you.update(this);\r\n        this.moveViewboxToYou();\r\n        if (!this.you.valid) {\r\n            this.gameover(t);\r\n        }\r\n    }\r\n    _you_are_invincible(t) {\r\n        this.you.life++;\r\n    }\r\n    _update_guide(t) {\r\n        this.guideLife--;\r\n        if (this.guideLife < 0)\r\n            this.removeUpdateFunctionLater.push(this._update_guide);\r\n    }\r\n    _update_things(t) {\r\n        const limit = this.you.sight * 3;\r\n        for (let i = this.enemies.length - 1; i >= 0; i--) {\r\n            const enemy = this.enemies[i];\r\n            if (!enemy.valid) {\r\n                this.enemies.splice(i, 1);\r\n                this.currentEnemiesNumber--;\r\n            }\r\n            else {\r\n                const distX = enemy.x - this.you.x;\r\n                const distY = enemy.y - this.you.y;\r\n                if ((Math.abs(distX) > limit || Math.abs(distY) > limit) && Math.hypot(distX, distY)) {\r\n                    this.enemies.splice(i, 1);\r\n                    this.currentEnemiesNumber--;\r\n                }\r\n            }\r\n        }\r\n        for (let i = this.tunas.length - 1; i >= 0; i--) {\r\n            if (!this.tunas[i].valid) {\r\n                this.tunas.splice(i, 1);\r\n            }\r\n        }\r\n        for (const enemy of this.enemies) {\r\n            enemy.update(this);\r\n        }\r\n        for (const tuna of this.tunas) {\r\n            tuna.update(this);\r\n        }\r\n        this.createThingRandom();\r\n    }\r\n    _update_timer(t) {\r\n        this.timer.update(t);\r\n    }\r\n    update(t) {\r\n        for (const updateFunction of this.updateFunctions) {\r\n            updateFunction.call(this, t);\r\n        }\r\n        let toRemove;\r\n        while (toRemove = this.removeUpdateFunctionLater.pop()) {\r\n            this.updateFunctions.splice(this.updateFunctions.indexOf(toRemove), 1);\r\n        }\r\n    }\r\n    hitTest() {\r\n        const you = this.you;\r\n        for (const enemy of this.enemies) {\r\n            if (_Thing__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hit(you, enemy)) {\r\n                you.health -= damage;\r\n                enemy.life = 0;\r\n            }\r\n        }\r\n        for (const tuna of this.tunas) {\r\n            if (_Thing__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hit(you, tuna)) {\r\n                you.health = you.maxHealth;\r\n                you.life = you.maxLife;\r\n                tuna.life = 0;\r\n            }\r\n        }\r\n    }\r\n    renderCount(context) {\r\n        context.font = '16px \"Exo 2\"';\r\n        context.textBaseline = \"middle\";\r\n        context.fillStyle = \"#69d7ff40\";\r\n        context.textAlign = 'center';\r\n        context.fillText(this.totalEnemiesNumber.toString(), this.viewbox.x, this.viewbox.y - this.viewbox.height / 4);\r\n    }\r\n    renderTunaDirection(context) {\r\n        context.fillStyle = \"#FFB30040\";\r\n        const farDist = followDistance * 2;\r\n        const nearDist = farDist - 8;\r\n        const theta = Math.PI / 15;\r\n        const { x, y } = this.you;\r\n        for (const tuna of this.tunas) {\r\n            const dx = tuna.x - x;\r\n            const dy = tuna.y - y;\r\n            if (Math.hypot(dx, dy) > farDist) {\r\n                const angle = Math.atan2(dy, dx);\r\n                context.beginPath();\r\n                context.moveTo(x + Math.cos(angle) * farDist, y + Math.sin(angle) * farDist);\r\n                context.lineTo(x + Math.cos(angle - theta) * nearDist, y + Math.sin(angle - theta) * nearDist);\r\n                context.lineTo(x + Math.cos(angle + theta) * nearDist, y + Math.sin(angle + theta) * nearDist);\r\n                context.fill();\r\n            }\r\n        }\r\n    }\r\n    render(context) {\r\n        if (this.guideLife >= 0)\r\n            for (const guide of this.guideTexts) {\r\n                guide.render(context, this.guideLife / textMaxLife);\r\n            }\r\n        for (const enemies of this.enemies)\r\n            enemies.render(context);\r\n        for (const tuna of this.tunas)\r\n            tuna.render(context);\r\n        this.you.render(context);\r\n        this.you.renderSight(context);\r\n        this.you.renderYourUI(context, this.viewboxReplica.x, this.viewboxReplica.y, followDistance * 2);\r\n        this.renderTunaDirection(context);\r\n        this.timer.render(context, this.viewbox.x, this.viewbox.y + this.viewbox.height / 4);\r\n        this.renderCount(context);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./app/Game.ts?");

/***/ }),

/***/ "./app/Input.ts":
/*!**********************!*\
  !*** ./app/Input.ts ***!
  \**********************/
/*! exports provided: CoordinateState, Detector, MouseInput, TouchInput */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CoordinateState\", function() { return CoordinateState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Detector\", function() { return Detector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MouseInput\", function() { return MouseInput; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TouchInput\", function() { return TouchInput; });\n/*\r\n 리스너를 여러 개로 만들려면 다음 중 하나는 해야 한다.\r\n \r\n - 리스너가 독자적인 큐를 갖도록 하기\r\n 중앙 집중적 큐를 사용하는 이유는 메시지 우선(메시지 1을 리스너 1에게 디스패치, 메시지 1을 리스너 2에게 디스패치, ...)으로 업데이트하기 위함이다.\r\n 리스너 중심으로 메시지를 직접 처리하는 것보다 상태 전이가 더 용이할 수 있기 때문 (아닐 수도 있고. 이건 정말로 use-cases에 따라 다르다.)\r\n 그러나 이렇게 하면서도 acceptCoordinate까지 쓰려면 어떤 리스너들에 대해서는 메시지를 스킵해야 한다. 어떤 입력에 대해서 리스너가 받아들일수도, 안받아들일수도 있기 때문. 그러려면 또다시 받아들일 것인지 말것인지 여부를 판단해야 하는데 그냥 독자적 큐를 쓰는게 낫지.\r\n \r\n acceptCoordinate를 썼던 이유는\r\n 1. 미들웨어가 클릭한 채로 드래그를 중요시하는 경우에 마우스를 클릭하지 않고 움직이는 것으로 인해 발생하는 이벤트를 무시하기 위하여 리스너를 동적으로 연결/연결 해제하기 위함이다.\r\n 2. 모델의 요구사항이다. 이거는 모델 선에서 처리해야지 씹놈아\r\n \r\n 터치 인터페이스인 경우에는 그 특성상 리스너를 굳이 연결 해제할 필요가 없다.\r\n \r\n 그래서 acceptCoordinate를 모델 책임으로 넘겼고, 리스너가 독자적 큐를 갖도록 했다! 원한다면 리스너를 여러 개로 만들 수 있다\r\n \r\n ### 참고\r\n push와 dispatch가 별개인 이유는 순전히 이것이 rAF 중심적으로 설계되었고, 모든 상태 변경은 rAF에서만 허용한다고 가정하기 때문이다. dispatch는 rAF 중에만, push는 이벤트가 발생할 수 있는 어떠한 타이밍에서든지 일어날 수 있다. 아직까지는 rAF에서 메시지 dispatch를 먼저 실행하고 실질적 모델 업데이트를 하기 때문에 그게 그거같아 보이지만, 모델 업데이트를 먼저 하도록 바꾸는 것도 가능하다. 그럼 coord도 마저 바꿔야되는데 어 시발 이게 뭐지?\r\n*/\r\n/**\r\n * 전적으로 rAF-Sync를 위해 표현되는 위치 객체로, 현재 rAF에서의 위치와 직전 rAF에서의 위치를 나타낸다.\r\n * 직전 \"이벤트\"의 위치가 아닌 직전 \"rAF\"인 것에 주의할 것!\r\n * */\r\nclass CoordinateState {\r\n    /** @readonly 현재 x좌표 */\r\n    get x() { return this.currentX; }\r\n    /** @readonly 현재 y좌표 */\r\n    get y() { return this.currentY; }\r\n    /** @readonly 직전 rAF에서 X좌표 */\r\n    get beforeX() { return this._beforeX; }\r\n    /** @readonly 직전 rAF에서 y좌표 */\r\n    get beforeY() { return this._beforeY; }\r\n    /** @readonly 직전 rAF에서 현재 rAF까지의 x 변위 */\r\n    get moveX() {\r\n        return (this.beforeX != null) && (this.currentX != null) ? (this.currentX - this._beforeX) : 0;\r\n    }\r\n    /** @readonly 직전 rAF에서 현재 rAF까지의 y 변위 */\r\n    get moveY() {\r\n        return (this.beforeY != null) && (this.currentY != null) ? (this.currentY - this._beforeY) : 0;\r\n    }\r\n    /** 쌩 입력값을 이것으로 한다. */\r\n    input(x, y) {\r\n        this.inputX = x;\r\n        this.inputY = y;\r\n    }\r\n    /** (눌림을 위해) current값을 강제로 이것으로 한다. */\r\n    shim(x, y) {\r\n        this.currentX = x;\r\n        this.currentY = y;\r\n    }\r\n    /** 현재 상태를 이전 상태로, 쌩 입력 좌표를 현재 상태로 전이시킨다. */\r\n    pulse() {\r\n        this._beforeX = this.currentX;\r\n        this._beforeY = this.currentY;\r\n        this.currentX = this.inputX;\r\n        this.currentY = this.inputY;\r\n    }\r\n}\r\n/** 입력 인터페이스를 눈치껏 알아채는 객체 */\r\nclass Detector {\r\n    constructor() {\r\n        this.detected = false;\r\n    }\r\n    disconnect() {\r\n        document.removeEventListener('mousedown', this.mouse);\r\n        document.removeEventListener('touchstart', this.touch);\r\n        this.detected = true;\r\n    }\r\n    open() {\r\n        if (this.detected)\r\n            return;\r\n        this.mouse = ev => {\r\n            this.whenItsMouse(ev);\r\n            this.disconnect();\r\n        };\r\n        this.touch = ev => {\r\n            this.whenItsTouch(ev);\r\n            this.disconnect();\r\n        };\r\n        document.addEventListener('mousedown', this.mouse);\r\n        document.addEventListener('touchstart', this.touch);\r\n    }\r\n}\r\n/**\r\n * 마우스 입력을 받아들여서 리스너에게 전달하는 클래스\r\n * 이 클래스는 requestAnimationFrame()을 사용한 업데이트 패턴에 특화된 구조를 가지고 있다.\r\n * 중요하고 양이 비교적 적은 이벤트(마우스 누름, 마우스 놓음)는 매 이벤트 루프마다 놓치지 않고 캡쳐해 두고, 압도적으로 많이 발생하고 중요하지 않은 이벤트(마우스 움직임)는 변화에 따라 \"현재 상태\"와 \"직전 상태\"만을 저장해 두고 rAF에서 그 상태를 참조하도록 하고 있다.\r\n * 이 입력 객체는 특히 \"마우스를 누를 때\"에만 실제 좌표를 전달한다.\r\n */\r\nclass MouseInput {\r\n    constructor() {\r\n        /** (rAF?) 지금 누르고 있는 버튼 */\r\n        this.buttons = 0;\r\n        /**\r\n         * 마우스 누름 발생 시, 언젠가 발생할 마우스 떼기에 대응하여 임시로 메시지를 만들어 저장해 둘 배열\r\n         * messagePool[n]은 n번 마우스 버튼 누름에 대응하는 임시 마우스 떼기 메시지이다.\r\n         * n번 마우스 버튼 떼기가 발생하면 messagePool[n]에 있는 메시지를 꺼내서 end 값을 입력하고 큐에 넣는다.\r\n         * */\r\n        this.messageCache = [];\r\n        /** rAF 발생 당시 마우스 누름 중일 때 사용할 수 있는 좌표 컴포넌트 */\r\n        this.coordinate = new CoordinateState();\r\n        /** 마우스 누름 이벤트 발생 시 실행된다.  */\r\n        this.onstart = (ev) => {\r\n            ev.preventDefault();\r\n            this.buttons = ev.buttons;\r\n            let startX = ev.offsetX;\r\n            let startY = ev.offsetY;\r\n            let id = ev.button;\r\n            let startTime = ev.timeStamp;\r\n            // pulse를 맞으면 currentX는 beforeX가 된다.\r\n            // 따라서 rAF가 발생하는 시점에서 이전 위치는 마우스 누름 위치로 간주된다.\r\n            this.coordinate.shim(startX, startY);\r\n            // 이것과 rAF 사이에 move가 발생하지 않으면 rAF 발생 시 혀재 위치 또한 마우스 누름 위치가 된다.\r\n            // rAF 발생 전에 move가 먼저 발생하면 input값을 덮어써서 걔들이 current값이 되겠지?\r\n            this.coordinate.input(startX, startY);\r\n            this.listener.push({ type: \"mousedown\", id, startX, startY, startTime });\r\n            // down-up pair를 위해 마우스 누름 위치를 저장한다.\r\n            this.messageCache[id] = { type: \"mouseup\", id, startX, startY, startTime };\r\n            return false;\r\n        };\r\n        /** 마우스 누름 여부와 상관없이 마우스를 움직일 때 실행된다. */\r\n        this.onmove = (ev) => {\r\n            this.coordinate.input(ev.offsetX, ev.offsetY);\r\n        };\r\n        this.onend = (ev) => {\r\n            this.buttons = ev.buttons;\r\n            /* MouseEvent.offsetX는 source 상대 위치이다. 띠용! */\r\n            let x = ev.offsetX;\r\n            let y = ev.offsetY;\r\n            // 마우스 누름 당시 저장했던 마우스 놓기 메시지를 가져온다.\r\n            let message = this.messageCache[ev.button];\r\n            delete this.messageCache[ev.button];\r\n            if (message) {\r\n                // 임시 메시지에 실제 마우스 놓기 데이터를 입력하여 메시지를 완성시킨다.\r\n                message.endX = x;\r\n                message.endY = y;\r\n                message.endTime = ev.timeStamp;\r\n                // 메시지를 큐에 입력한다.\r\n                this.listener.push(message);\r\n                // 현재 rAF의 마우스 위치를 떼기 위치로 간주한다.\r\n                // input에다 좌표를 넣어두면 rAF 발생 시 current로 내려가겠지?\r\n                this.coordinate.input(x, y);\r\n            }\r\n        };\r\n    }\r\n    /** 입력 컴포넌트를 뷰에 연결한다. */\r\n    connect(source, listener) {\r\n        this.disconnect();\r\n        this.source = source;\r\n        this.listener = listener;\r\n        this.source.addEventListener('mousedown', this.onstart);\r\n        this.source.addEventListener('mousemove', this.onmove);\r\n        document.addEventListener('mouseup', this.onend);\r\n    }\r\n    /** 입력 컴포넌트 연결을 해제한다. */\r\n    disconnect() {\r\n        let source = this.source;\r\n        if (source) {\r\n            source.removeEventListener('mousedown', this.onstart);\r\n            source.removeEventListener('mousemove', this.onmove);\r\n            document.removeEventListener('mouseup', this.onend);\r\n        }\r\n        this.source = null;\r\n        this.listener = null;\r\n    }\r\n    /**\r\n     * (rAF) 큐에 있는 메시지를 모두 정리하고, 상태를 전이시킨다.\r\n     *\r\n     * # 중요 : 메시지 큐, 메시지 버퍼에 쌓인 것들은 rAF와 독립적으로 발생한 것들이다. 따라서 메시지는 coordState와는 좆도 상관없다.\r\n     * */\r\n    update() {\r\n        this.listener.dispatchAll();\r\n        this.coordinate.pulse();\r\n        if (this.buttons)\r\n            this.listener.dispatchDrag(this.coordinate);\r\n    }\r\n}\r\nclass TouchInput {\r\n    constructor() {\r\n        this.messageCache = [];\r\n        /**\r\n         * 마우스는 항상 하나의 좌표지만 터치는 언제 어디서 어떤 터치가 생길지, 없어질지 모른다.\r\n         * 근데 메인 터치는 있어야 하는 법이고, 갑자기 메인 터치가 없어지면 여기 있던 놈들 중에서 한 녀석이 메인 터치를 계승한다.\r\n         * */\r\n        this.touchStateMap = [];\r\n        /** @private 메인 터치의 위치 */\r\n        this.coord = null;\r\n        this.scale = 1;\r\n        this.onstart = (ev) => {\r\n            // 이게 없을 때 캔버스를 스와이프하면 페이지가 스크롤되고 탭을 하면 일부 환경에서 mouseup,mousedown을 일으킨다.\r\n            // 타겟이 도큐먼트가 아니라면 스크롤되어선 안되겠지?\r\n            ev.preventDefault();\r\n            const startTime = ev.timeStamp;\r\n            let touchList = ev.changedTouches;\r\n            for (const touch of touchList) {\r\n                let startX = (touch.pageX - this.sourceLeft) * this.scale;\r\n                let startY = (touch.pageY - this.sourceTop) * this.scale;\r\n                let id = touch.identifier;\r\n                let state = new CoordinateState();\r\n                state.input(startX, startY);\r\n                state.shim(startX, startY);\r\n                this.touchStateMap[id] = state;\r\n                // 메인 터치가 없었다면 이 터치를 메인 터치로 설정한다.\r\n                if (!this.coord)\r\n                    this.coord = state;\r\n                this.listener.push({ type: \"touchstart\", id, startX, startY, startTime });\r\n                this.messageCache[id] = { type: \"touchend\", id, startX, startY, startTime };\r\n            }\r\n            return false;\r\n        };\r\n        this.onmove = (ev) => {\r\n            for (const touch of ev.changedTouches) {\r\n                if (touch.identifier in this.touchStateMap) {\r\n                    const state = this.touchStateMap[touch.identifier];\r\n                    let x = (touch.pageX - this.sourceLeft) * this.scale;\r\n                    let y = (touch.pageY - this.sourceTop) * this.scale;\r\n                    state.input(x, y);\r\n                }\r\n            }\r\n        };\r\n        this.onend = (ev) => {\r\n            for (const touch of ev.changedTouches) {\r\n                if (touch.identifier in this.touchStateMap) {\r\n                    const message = this.messageCache[touch.identifier];\r\n                    delete this.messageCache[touch.identifier];\r\n                    if (message) {\r\n                        const state = this.touchStateMap[touch.identifier];\r\n                        const x = (touch.pageX - this.sourceLeft) * this.scale;\r\n                        const y = (touch.pageY - this.sourceTop) * this.scale;\r\n                        message.endX = x;\r\n                        message.endY = y;\r\n                        message.endTime = ev.timeStamp;\r\n                        this.listener.push(message);\r\n                        state.input(x, y);\r\n                        // 놓은 위치의 터치 위치 상태를 뺀다.\r\n                        delete this.touchStateMap[touch.identifier];\r\n                        // 메이저 터치가 빠졌으면 후계자를 찾는다.\r\n                        if (this.coord == state) {\r\n                            this.coord = null;\r\n                            for (const i in this.touchStateMap) {\r\n                                if (this.touchStateMap.hasOwnProperty(i)) {\r\n                                    this.coord = this.touchStateMap[i];\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n    }\r\n    /** @readonly 메인 터치의 위치 */\r\n    get coordinate() { return this.coord; }\r\n    ;\r\n    connect(source, listener, scale = 1) {\r\n        this.disconnect();\r\n        this.source = source;\r\n        this.listener = listener;\r\n        this.scale = 1;\r\n        this.source.addEventListener('touchstart', this.onstart);\r\n        this.source.addEventListener('touchmove', this.onmove);\r\n        document.addEventListener('touchend', this.onend);\r\n        let { left, top } = source.getBoundingClientRect();\r\n        this.sourceLeft = left;\r\n        this.sourceTop = top;\r\n    }\r\n    disconnect() {\r\n        let source = this.source;\r\n        if (source) {\r\n            source.removeEventListener('touchstart', this.onstart);\r\n            source.removeEventListener('touchmove', this.onmove);\r\n            document.removeEventListener('touchend', this.onend);\r\n        }\r\n        this.source = null;\r\n        this.listener = null;\r\n    }\r\n    update() {\r\n        this.listener.dispatchAll();\r\n        for (const i in this.touchStateMap) {\r\n            if (this.touchStateMap.hasOwnProperty(i)) {\r\n                const state = this.touchStateMap[i];\r\n                state.pulse();\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./app/Input.ts?");

/***/ }),

/***/ "./app/Matrix2D.ts":
/*!*************************!*\
  !*** ./app/Matrix2D.ts ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Matrix2D; });\n/**\r\n * 이렇게 생긴 행렬을 나타낸다:\r\n *\r\n * ````plaintext\r\n * a 0 e\r\n * 0 d f\r\n * 0 0 1\r\n * ````\r\n * skew는 고려대상이 아니므로 b, c는 뺐다.\r\n */\r\nclass Matrix2D {\r\n    constructor(a, d, e, f) {\r\n        this.a = 1;\r\n        this.d = 1;\r\n        this.e = 0;\r\n        this.f = 0;\r\n        this.a = a;\r\n        this.d = d;\r\n        this.e = e;\r\n        this.f = f;\r\n    }\r\n    /** 모델 상에서의 어떤 지점이 뷰에 나타나는 위치 */\r\n    transformPoint(x, y) {\r\n        let { a, d, e, f } = this;\r\n        return [x * a + e, y * d + f];\r\n    }\r\n    /** 뷰의 어떤 지점을 찍었을 때 그 점의 모델 상에서의 위치 */\r\n    itransformPoint(x, y) {\r\n        let { a, d, e, f } = this;\r\n        return [(x - e) / a, (y - f) / d];\r\n    }\r\n    /** 모델 상의 두 지점이 뷰에 나타날 때 두 점의 변위의 각 성분 */\r\n    transformDimension(w, h) {\r\n        let { a, d } = this;\r\n        return [w * a, h * d];\r\n    }\r\n    /** 뷰에 나타난 변위의 각 성분의 모델에서의 길이 */\r\n    itransformDimension(w, h) {\r\n        let { a, d } = this;\r\n        return [w / a, h / d];\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./app/Matrix2D.ts?");

/***/ }),

/***/ "./app/Moving.ts":
/*!***********************!*\
  !*** ./app/Moving.ts ***!
  \***********************/
/*! exports provided: moveToTarget, friction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"moveToTarget\", function() { return moveToTarget; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"friction\", function() { return friction; });\nfunction moveToTarget(maxSpeed, acc, closeDistance) {\r\n    let { x, y, velX, velY, destX, destY } = this;\r\n    let dx = destX - x;\r\n    let dy = destY - y;\r\n    if (dx != 0 || dy != 0) {\r\n        let angle = Math.atan2(dy, dx);\r\n        let targetVelX = Math.cos(angle) * maxSpeed;\r\n        let targetVelY = Math.sin(angle) * maxSpeed;\r\n        let distance = Math.hypot(dx, dy);\r\n        if (distance < closeDistance) {\r\n            targetVelX *= distance / closeDistance;\r\n            targetVelY *= distance / closeDistance;\r\n        }\r\n        let dVelX = targetVelX - velX;\r\n        let dVelY = targetVelY - velY;\r\n        this.velX += Math.sign(dVelX) * Math.min(Math.abs(dVelX), acc);\r\n        this.velY += Math.sign(dVelY) * Math.min(Math.abs(dVelY), acc);\r\n    }\r\n}\r\nfunction friction(stopVel = 0.001) {\r\n    this.velX *= 0.9;\r\n    if (Math.abs(this.velX) < stopVel)\r\n        this.velX = 0;\r\n    this.velY *= 0.9;\r\n    if (Math.abs(this.velY) < stopVel)\r\n        this.velY = 0;\r\n}\r\n\n\n//# sourceURL=webpack:///./app/Moving.ts?");

/***/ }),

/***/ "./app/RAFPulseClock.ts":
/*!******************************!*\
  !*** ./app/RAFPulseClock.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return RAFPulseClock; });\nclass RAFPulseClock {\r\n    constructor(update) {\r\n        this.a = null;\r\n        this.update = update;\r\n    }\r\n    start() {\r\n        this.a = (t) => {\r\n            this.update(t);\r\n            requestAnimationFrame(this.a);\r\n        };\r\n        requestAnimationFrame(this.a);\r\n    }\r\n    end() {\r\n        this.a = (t) => {\r\n            this.a = null;\r\n        };\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./app/RAFPulseClock.ts?");

/***/ }),

/***/ "./app/Thing.ts":
/*!**********************!*\
  !*** ./app/Thing.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Thing; });\nclass Thing {\r\n    constructor(type, x, y, r, color, life) {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.r = 0;\r\n        this.velX = 0;\r\n        this.velY = 0;\r\n        this.type = type;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.r = r;\r\n        this.color = color;\r\n        this.life = life;\r\n    }\r\n    update(game) {\r\n        this.x += this.velX;\r\n        this.y += this.velY;\r\n        this.life--;\r\n    }\r\n    render(context) {\r\n        let { x, y, r, color } = this;\r\n        context.strokeStyle = color;\r\n        context.lineWidth = 1;\r\n        context.beginPath();\r\n        context.ellipse(x, y, r, r, 0, 0, Math.PI * 2);\r\n        context.stroke();\r\n    }\r\n    get valid() {\r\n        return this.life > 0;\r\n    }\r\n    static hit(a, b, torusWidth, torusHeight) {\r\n        let { x: ax, y: ay, r: ar } = a;\r\n        let { x: bx, y: by, r: br } = b;\r\n        return Math.hypot(ax - bx, ay - by) < ar + br;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./app/Thing.ts?");

/***/ }),

/***/ "./app/Timer.ts":
/*!**********************!*\
  !*** ./app/Timer.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Timer; });\n/** 마이크로초를 mm : ss . ss 로 나눈다. */\r\nfunction formatMs(ms) {\r\n    let val = Math.round(ms / 10);\r\n    let min = Math.floor(val / 6000);\r\n    let centisec = val % 6000;\r\n    let centisec_str = centisec.toString();\r\n    let centisec_len = centisec_str.length;\r\n    if (centisec_len < 4) {\r\n        let a = Array(4 - centisec_len);\r\n        a.fill('0');\r\n        centisec_str = a.join('') + centisec_str;\r\n    }\r\n    let min_str = min.toString();\r\n    let min_len = min_str.length;\r\n    if (min_len < 2) {\r\n        let a = Array(2 - min_len);\r\n        a.fill('0');\r\n        min_str = a.join('') + min_str;\r\n    }\r\n    return [min_str, centisec_str.substr(0, 2), centisec_str.substr(2, 2)];\r\n}\r\n/**\r\n * 타이머 컴포넌트\r\n * DOMHighResTimestamp 때문에 로직이 은근 복잡하다.\r\n * */\r\nclass Timer {\r\n    constructor(width, size) {\r\n        /** 시작 버튼을 누른 시각 */\r\n        this.startTime = null;\r\n        /** 퍼즐이 중단된 시각 */\r\n        this.endTime = null;\r\n        /** rAF에 의해 입력되는 시각 */\r\n        this.currentTime = 0;\r\n        // this.y = height / 2;\r\n        this.width = width;\r\n        this.fontSize = size;\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    set width(v) {\r\n        this._width = v;\r\n        this.w_3 = v / 3;\r\n        this.w_6 = v / 6;\r\n    }\r\n    start(startTime) {\r\n        this.startTime = startTime;\r\n        this.endTime = null;\r\n    }\r\n    end(endTime) {\r\n        this.endTime = endTime;\r\n    }\r\n    reset() {\r\n        this.startTime = null;\r\n        this.endTime = null;\r\n        this.currentTime = null;\r\n    }\r\n    update(t) {\r\n        this.currentTime = t;\r\n    }\r\n    render(context, x, y) {\r\n        // let { y, left, w_3, w_6 } = this;\r\n        let { w_3, w_6 } = this;\r\n        let left = x - this.width / 2;\r\n        context.font = this.fontSize + 'px \"Exo 2\"';\r\n        context.textBaseline = \"middle\";\r\n        context.fillStyle = \"#69d7ff40\";\r\n        context.textAlign = 'center';\r\n        let [min, sec, cs] = formatMs(this.currentTime - this.startTime);\r\n        context.fillText(min, left + w_6, y);\r\n        context.fillText('\\'', left + w_3, y);\r\n        context.fillText('\"', left + w_3 * 2, y);\r\n        context.textAlign = 'right';\r\n        context.fillText(sec[0], left + w_3 + w_6, y);\r\n        context.fillText(cs[0], left + w_3 * 2 + w_6, y);\r\n        context.textAlign = 'left';\r\n        context.fillText(sec[1], left + w_3 + w_6, y);\r\n        context.fillText(cs[1], left + w_3 * 2 + w_6, y);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./app/Timer.ts?");

/***/ }),

/***/ "./app/View.ts":
/*!*********************!*\
  !*** ./app/View.ts ***!
  \*********************/
/*! exports provided: Viewbox, View */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Viewbox\", function() { return Viewbox; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"View\", function() { return View; });\n/* harmony import */ var _Matrix2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Matrix2D */ \"./app/Matrix2D.ts\");\n\r\nclass Viewbox {\r\n    constructor(view, context, rWidth, rHeight) {\r\n        this.view = view;\r\n        this.context = context;\r\n        // View 클래스는 캔버스 여러분이 가지고 있던 기존의 변환 행렬을 존중합니다!!\r\n        let { a, d, e, f } = this.context.getTransform();\r\n        this.matrix = new _Matrix2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"](a, d, e, f);\r\n        this._width = rWidth / a;\r\n        this._height = rHeight / d;\r\n        this._left = -e;\r\n        this._top = -f;\r\n    }\r\n    get left() { return this._left; }\r\n    get top() { return this._top; }\r\n    get width() { return this._width; }\r\n    get height() { return this._height; }\r\n    get x() { return this._left + this._width / 2; }\r\n    get y() { return this._top + this._height / 2; }\r\n    get right() { return this._left + this._width; }\r\n    get bottom() { return this._top + this._height; }\r\n    /** 뷰박스의 가운데가 지정한 좌표값이 되도록 뷰박스를 이동시킨다. */\r\n    setPosition(x = null, y = null) {\r\n        const matrix = this.matrix;\r\n        let { a, d } = matrix;\r\n        if (x != null)\r\n            this._left = x - this._width / 2;\r\n        if (y != null)\r\n            this._top = y - this._height / 2;\r\n        matrix.e = -this._left * a;\r\n        matrix.f = -this._top * d;\r\n        this.context.setTransform(a, 0, 0, d, matrix.e, matrix.f);\r\n    }\r\n    /** 뷰박스를 이동시킨다.\r\n     * 신기하게도 Context.translate는 입력값 만큼만 변환시키는 것이 아니라 변환행렬의 다른 값들이 함께 적용된다. */\r\n    move(dx, dy) {\r\n        const matrix = this.matrix;\r\n        matrix.e += -dx * matrix.a;\r\n        matrix.f += -dy * matrix.d;\r\n        this._left += dx;\r\n        this._top += dy;\r\n        this.context.translate(-dx, -dy);\r\n    }\r\n    /**\r\n     * 뷰박스의 크기를 설정한다.\r\n     * height가 없으면 __뷰(캔버스)의 종횡 비율__이 적용된다.\r\n     * 아무런 인수가 없으면 기존의 width가 적용된다.\r\n     * */\r\n    setSize(width, height) {\r\n        let { x, y } = this;\r\n        (width != null) ? this._width = width : width = this._width;\r\n        if (height == null)\r\n            height = width * this.view.height / this.view.width;\r\n        this._height = height;\r\n        this._left = x - width / 2;\r\n        this._top = y - height / 2;\r\n        let a = this.view.width / width;\r\n        let d = this.view.height / height;\r\n        let e = -this._left * a;\r\n        let f = -this._top * d;\r\n        Object.assign(this.matrix, { a, d, e, f });\r\n        this.context.setTransform(a, 0, 0, d, e, f);\r\n    }\r\n    /** 뷰박스가 보고 있는 곳을 청소한다. */\r\n    clearRect() {\r\n        this.context.clearRect(this._left - 5, this._top - 5, this._width + 10, this._height + 10);\r\n    }\r\n}\r\n/**\r\n * 기본적으로는 캔버스와 같으나, 뷰포트(Viewport)를 고려하여 크기 조절 시 컨텍스트의 변환 행렬을 조절하는 기능을 추가로 갖고 있다. 이러한 사양 때문에 실제 크기 속성을 함께 가지고 있다.\r\n */\r\nclass View {\r\n    /**\r\n     * 캔버스를 기반으로 뷰를 생성한다.\r\n     * 기존에 설정되어 있던 변환행렬을 기반으로 위치, 배율이 현재 객체에 자동으로 등록된다.\r\n     */\r\n    constructor(canvas) {\r\n        this.canvas = canvas;\r\n        this.context = canvas.getContext('2d');\r\n        this.rWidth = this.canvas.width;\r\n        this.rHeight = this.canvas.height;\r\n        this.viewbox = new Viewbox(this, this.context, this.rWidth, this.rHeight);\r\n    }\r\n    get width() { return this.rWidth; }\r\n    get height() { return this.rHeight; }\r\n    /**\r\n     * 뷰(캔버스)의 크기를 변경하고, 뷰박스 크기는 변경되지 않도록 context의 변환행렬 값을 적절한 것으로 채워 넣는다.\r\n     * height가 없으면 현재 뷰(캔버스)의 width 변화에 비례한 값이 자동 설정된다.\r\n     * */\r\n    setViewSize(width, height) {\r\n        if (height == null)\r\n            height = width * this.rHeight / this.rWidth;\r\n        this.rWidth = width;\r\n        this.rHeight = height;\r\n        this.canvas.width = width;\r\n        this.canvas.height = height;\r\n        this.viewbox.setSize();\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./app/View.ts?");

/***/ }),

/***/ "./app/You.ts":
/*!********************!*\
  !*** ./app/You.ts ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return You; });\n/* harmony import */ var _Thing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Thing */ \"./app/Thing.ts\");\n/* harmony import */ var _Moving__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Moving */ \"./app/Moving.ts\");\n\r\n\r\nconst yourMaxSpeed = 0.8;\r\nconst yourAcc = 0.25;\r\nconst closeDistance = 20;\r\nconst yourSize = 5;\r\nconst yourLife = 1800;\r\nconst yourHealth = 60;\r\nconst sight = 120;\r\n// 참고 : Life는 수명이고 Health는 체력이다. 시간이 흐르면 Life가 깎이고, 철충한테 맞으면 Health가 깎인다.\r\nclass You extends _Thing__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n    constructor() {\r\n        super(\"you\", 0, 0, yourSize, \"#FFFF00\", yourLife);\r\n        this.speed = yourMaxSpeed;\r\n        this.acc = yourAcc;\r\n        this.closeDistance = closeDistance;\r\n        this.sight = sight;\r\n        this.friction = _Moving__WEBPACK_IMPORTED_MODULE_1__[\"friction\"].bind(this);\r\n        this.moveToTarget = _Moving__WEBPACK_IMPORTED_MODULE_1__[\"moveToTarget\"].bind(this, yourMaxSpeed, yourAcc, closeDistance);\r\n        this.updatePosition = this.friction;\r\n        this.init();\r\n    }\r\n    /** 너를 처음 상태로 만든다. */\r\n    init() {\r\n        this.life = yourLife;\r\n        this.maxLife = yourLife;\r\n        this.health = yourHealth;\r\n        this.maxHealth = yourHealth;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.velX = 0;\r\n        this.velY = 0;\r\n        this.destX = null;\r\n        this.destY = null;\r\n    }\r\n    setDestination(x, y) {\r\n        this.destX = x;\r\n        this.destY = y;\r\n        this.updatePosition = this.moveToTarget;\r\n    }\r\n    neutralizeDestination() {\r\n        this.destX = null;\r\n        this.destY = null;\r\n        this.updatePosition = this.friction;\r\n    }\r\n    /** @override */\r\n    update(game) {\r\n        super.update(game);\r\n        this.updatePosition();\r\n    }\r\n    get valid() {\r\n        return this.life > 0 && this.health > 0;\r\n    }\r\n    render(context) {\r\n        super.render(context);\r\n        this.renderSquare(context);\r\n    }\r\n    renderSight(context) {\r\n        const { x, y, sight } = this;\r\n        let grad = context.createRadialGradient(x, y, sight - 50, x, y, sight + 25);\r\n        grad.addColorStop(0.0, '#00000000');\r\n        grad.addColorStop(1.0, '#000000FF');\r\n        context.fillStyle = grad;\r\n        context.fillRect(x - sight * 2, y - sight * 2, sight * 4, sight * 4);\r\n    }\r\n    renderLife(context, x, y, distance) {\r\n        distance -= 2.5;\r\n        let startAngle = Math.PI * 5 / 6;\r\n        let { life, maxLife } = this;\r\n        let ratio = Math.max(0, life / maxLife);\r\n        let endAngle = startAngle + Math.PI * ratio / 3;\r\n        context.lineWidth = 5;\r\n        context.strokeStyle = \"#ffd24a80\";\r\n        context.beginPath();\r\n        context.ellipse(x, y, distance, distance, 0, startAngle, endAngle);\r\n        context.stroke();\r\n    }\r\n    renderHealth(context, x, y, distance) {\r\n        distance -= 2.5;\r\n        let startAngle = Math.PI / 6;\r\n        let { health, maxHealth } = this;\r\n        let ratio = Math.max(0, health / maxHealth);\r\n        let endAngle = startAngle - Math.PI * ratio / 3;\r\n        context.lineWidth = 5;\r\n        context.strokeStyle = \"#69d7ff80\";\r\n        context.beginPath();\r\n        context.ellipse(x, y, distance, distance, 0, startAngle, endAngle, true);\r\n        context.stroke();\r\n    }\r\n    renderSquare(context) {\r\n        let { x, y } = this;\r\n        context.strokeStyle = \"#FFFFFF\";\r\n        context.lineWidth = 1;\r\n        context.strokeRect(x - 18, y - 27, 36, 54);\r\n    }\r\n    renderYourUI(context, x, y, distance) {\r\n        this.renderLife(context, x, y, distance);\r\n        this.renderHealth(context, x, y, distance);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./app/You.ts?");

/***/ }),

/***/ "./app/index.ts":
/*!**********************!*\
  !*** ./app/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _View__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./View */ \"./app/View.ts\");\n/* harmony import */ var _Input__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Input */ \"./app/Input.ts\");\n/* harmony import */ var _Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Game */ \"./app/Game.ts\");\n/* harmony import */ var _RAFPulseClock__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RAFPulseClock */ \"./app/RAFPulseClock.ts\");\n\r\n\r\n\r\n\r\nconst gameCanvas = document.getElementById('game-canvas');\r\ngameCanvas.getContext('2d').setTransform(1, 0, 0, 1, 120, 160);\r\ngameCanvas.addEventListener('contextmenu', ev => {\r\n    ev.preventDefault();\r\n    return false;\r\n});\r\nconst statusCanvas = document.getElementById('timer-canvas');\r\nconst statusContext = statusCanvas.getContext('2d');\r\nstatusContext.textBaseline = 'middle';\r\nstatusContext.fillStyle = '#FFFFFF';\r\nconst view = new _View__WEBPACK_IMPORTED_MODULE_0__[\"View\"](gameCanvas);\r\nview.setViewSize(360);\r\nconst game = new _Game__WEBPACK_IMPORTED_MODULE_2__[\"default\"](view.viewbox);\r\nconst input = new _Input__WEBPACK_IMPORTED_MODULE_1__[\"MouseInput\"]();\r\ninput.connect(view.canvas, game);\r\nfunction fitSize() {\r\n    let w, h;\r\n    let viewRatio = view.width / view.height;\r\n    if (window.innerWidth / window.innerHeight > viewRatio) {\r\n        h = window.innerHeight * 0.8;\r\n        w = h * viewRatio;\r\n    }\r\n    else {\r\n        w = window.innerWidth * 0.8;\r\n        h = w / viewRatio;\r\n    }\r\n    view.setViewSize(w);\r\n}\r\nwindow.addEventListener('resize', fitSize);\r\nwindow.addEventListener('load', fitSize);\r\nconst gridStep = 20;\r\nfunction renderGrid(view) {\r\n    let { viewbox, context } = view;\r\n    const { left, right, top, bottom, x: viewboxX, y: viewboxY } = viewbox;\r\n    const startX = (Math.round(left / gridStep) - 1) * gridStep;\r\n    const startY = (Math.round(top / gridStep) - 1) * gridStep;\r\n    const endX = (Math.round(right / gridStep) + 1) * gridStep;\r\n    const endY = (Math.round(bottom / gridStep) + 1) * gridStep;\r\n    context.fillStyle = '#80808040';\r\n    for (let x = startX; x < endX; x += gridStep) {\r\n        for (let y = startY; y < endY; y += gridStep) {\r\n            context.fillRect(x - 1, y - 1, 2, 2);\r\n        }\r\n    }\r\n    context.fillStyle = '#80808020';\r\n    for (let x = startX; x < endX; x += gridStep) {\r\n        for (let y = startY; y < endY; y += gridStep) {\r\n            let x_ = x + (x - viewboxX) / 10;\r\n            let y_ = y + (y - viewboxY) / 10;\r\n            context.fillRect(x_ - 2, y_ - 2, 4, 4);\r\n        }\r\n    }\r\n}\r\nconst clock = new _RAFPulseClock__WEBPACK_IMPORTED_MODULE_3__[\"default\"](t => {\r\n    input.update();\r\n    game.hitTest();\r\n    game.update(t);\r\n    view.viewbox.clearRect();\r\n    renderGrid(view);\r\n    game.render(view.context);\r\n});\r\nclock.start();\r\n\n\n//# sourceURL=webpack:///./app/index.ts?");

/***/ })

/******/ });